<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Welcome to the bundle</title>
 <link href="http://welcometothebundle.com/atom.xml" rel="self"/>
 <link href="http://welcometothebundle.com"/>
 <updated>2013-12-03T18:59:12+01:00</updated>
 <id>http://welcometothebundle.com</id>
 <author>
   <name>liuggio</name>
   <email>liuggio@liuggio</email>
 </author>

 
 <entry>
   <title>part 3 - Symfony2 API: the rest of REST</title>
   <link href="http://welcometothebundle.com/symfony2-rest-api-the-best-way-part-3"/>
   <updated>2013-12-03T13:00:00+01:00</updated>
   <id>http://welcometothebundle.com/symfony2-rest-api-the-best-way-part-3</id>
   <content type="html">&lt;h3 id='part_3__the_rest_of_rest'&gt;Part 3 - the rest of rest.&lt;/h3&gt;

&lt;p&gt;This is trilogy&amp;#8217;s final, in the part1 &amp;#8217;&lt;a href='http://welcometothebundle.com/symfony2-rest-api-the-best-2013-way/'&gt;best web API with Symfony2&lt;/a&gt;&amp;#8217; we created the application and the bundle, we wrote the &lt;code&gt;GET&lt;/code&gt; method, we also talked about the importance of the Interfaces, the content negotiation, and we gave an example of dumb controllers and smart services&amp;#8230;&lt;/p&gt;

&lt;p&gt;In the part2 &amp;#8217;&lt;a href='http://welcometothebundle.com/symfony2-rest-api-the-best-2013-way/'&gt;REST and Symfony the best way&lt;/a&gt;&amp;#8217; we created a new &lt;code&gt;Page&lt;/code&gt; via &lt;strong&gt;REST API&lt;/strong&gt;, we talked about &lt;code&gt;idempotent&lt;/code&gt; and &lt;code&gt;safe&lt;/code&gt; methods, and we understood how much the form is important&amp;#8230;&lt;/p&gt;

&lt;p&gt;In this article we are going to show how to properly modify a given resource using &lt;code&gt;PUT&lt;/code&gt;,&lt;code&gt;PATCH&lt;/code&gt;, how to handle different role for the Page resource, and how to disable the CRSF protection only when using API.&lt;/p&gt;

&lt;h2 id='the_github_repository'&gt;The github repository&lt;/h2&gt;

&lt;p&gt;There&amp;#8217;s a repository at &lt;a href='https://github.com/liuggio/symfony2-rest-api-the-best-2013-way/'&gt;liuggio/symfony2-rest-api-the-best-2013-way&lt;/a&gt; you could see the working code using the tag &lt;code&gt;part3&lt;/code&gt; with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;php composer.phar create-project liuggio/symfony2-rest-api-the-best-2013-way blog-rest-symfony2 -sdev
cd blog-rest-symfony2
git checkout -f part3
bin/phpunit -c app&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All the tags for the demo project are at &lt;a href='https://github.com/liuggio/symfony2-rest-api-the-best-2013-way/tags'&gt;tags&lt;/a&gt;, and also you could compare the 2 articles with &lt;a href='https://github.com/liuggio/symfony2-rest-api-the-best-2013-way/compare/part2...part3'&gt;compare/part2&amp;#8230;part3&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id='this_is_a_crud_world'&gt;This is a CRUD world&lt;/h2&gt;

&lt;p&gt;In the second article, we also saw how to properly use the HTTP-verbs, if you have to create a resource you should use the &lt;code&gt;POST&lt;/code&gt; method, if you want to fetch a resource you should use the &lt;code&gt;GET&lt;/code&gt; method, you have all the tools in order to create a CRUD (Create, Read, Update and Delete) with REST.&lt;/p&gt;
&lt;blockquote&gt;
The key principles of REST involve separating your API into logical resources. These resources are manipulated using HTTP requests where the method (GET, POST, PUT, PATCH, DELETE) has specific meaning.&lt;small&gt;Best Practices for Designing a Pragmatic RESTful API&lt;/small&gt;
&lt;/blockquote&gt;&lt;blockquote&gt;
The great thing about REST is that you're leveraging existing HTTP methods to implement significant functionality on just a single /tickets endpoint. There are no method naming conventions to follow and the URL structure is clean and clear.&lt;small&gt;Best Practices for Designing a Pragmatic RESTful API&lt;/small&gt;
&lt;/blockquote&gt;
&lt;h2 id='the_update_implementation'&gt;The update implementation&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;PUT&lt;/code&gt; method is used to replace all the content of a resource, the &lt;code&gt;PATCH&lt;/code&gt; method is utilized instead to partially update a resource.&lt;/p&gt;

&lt;h3 id='put_that_patch'&gt;PUT that PATCH&lt;/h3&gt;

&lt;p&gt;As always we need the stories and the tests before coding:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;PUT&lt;/strong&gt; - given a Page, is possible to replace all its proprieties, and if that page doesn&amp;#8217;t exist should be created.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;PATCH&lt;/strong&gt; - given a Page, is possible to replace some proprieties.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id='githubs_star'&gt;github&amp;#8217;s star&lt;/h3&gt;

&lt;p&gt;If you where github, how did you develop the API in order to add a star to a Gist?&lt;/p&gt;

&lt;p&gt;Story: A user should be able to &amp;#8216;star&amp;#8217; a gist.&lt;/p&gt;

&lt;p&gt;Github api/v3 uses:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PUT /gists/:id/star - to &amp;#8216;star&amp;#8217; a gist and it will response a &lt;code&gt;204 No Content&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;DELETE /gists/:id/star - to &amp;#8216;unstar&amp;#8217; a gist and it will response a &lt;code&gt;204 No Content&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;GET /gists/:id/star - to check if a gist is starred was starred will response a &lt;code&gt;204 No Content&lt;/code&gt; and return a &lt;code&gt;404&lt;/code&gt; if it wasn&amp;#8217;t.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id='put_the_implementation'&gt;PUT the implementation&lt;/h3&gt;

&lt;p&gt;The implementation of the PUT and PATCH methods should be in our service called &lt;code&gt;PageHandler&lt;/code&gt;, all the job is already done by the &lt;code&gt;processForm&lt;/code&gt; function that we have developed in the last article.&lt;/p&gt;

&lt;p&gt;Adding to &lt;code&gt;PageHandlerInterface&lt;/code&gt; the new methods, the &lt;code&gt;PageHandler&lt;/code&gt; will be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Edit a Page, or create if not exist.
 *
 * @param PageInterface $page
 * @param array         $parameters
 *
 * @return PageInterface
 */
public function put(PageInterface $page, array $parameters)
{
    return $this-&amp;gt;processForm($page, $parameters, &amp;#39;PUT&amp;#39;);
}

/**
 * Partially update a Page.
 *
 * @param PageInterface $page
 * @param array         $parameters
 *
 * @return PageInterface
 */
public function patch(PageInterface $page, array $parameters)
{
    return $this-&amp;gt;processForm($page, $parameters, &amp;#39;PATCH&amp;#39;);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The function Put doesn&amp;#8217;t create the resource.&lt;/p&gt;

&lt;h4 id='so__easy'&gt;So #@* easy?&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;yes!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The functions need a Page object and its parameters, the form will do the magic.&lt;/p&gt;

&lt;h3 id='the_controller'&gt;The Controller&lt;/h3&gt;

&lt;p&gt;In the controller we have to handle the HTTP status code, the headers, and the page object.&lt;/p&gt;

&lt;p&gt;The tests for putAction are two, one for the creation, and one for the modification:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function testJsonPutPageActionShouldModify()
{
    $fixtures = array(&amp;#39;Acme\BlogBundle\Tests\Fixtures\Entity\LoadPageData&amp;#39;);
    $this-&amp;gt;customSetUp($fixtures);
    $pages = LoadPageData::$pages;
    $page = array_pop($pages);

    $this-&amp;gt;client-&amp;gt;request(&amp;#39;GET&amp;#39;, sprintf(&amp;#39;/api/v1/pages/%d.json&amp;#39;, $page-&amp;gt;getId()), array(&amp;#39;ACCEPT&amp;#39; =&amp;gt; &amp;#39;application/json&amp;#39;));
    $this-&amp;gt;assertEquals(200, $this-&amp;gt;client-&amp;gt;getResponse()-&amp;gt;getStatusCode(), $this-&amp;gt;client-&amp;gt;getResponse()-&amp;gt;getContent());

    $this-&amp;gt;client-&amp;gt;request(
        &amp;#39;PUT&amp;#39;,
        sprintf(&amp;#39;/api/v1/pages/%d.json&amp;#39;, $page-&amp;gt;getId()),
        array(),
        array(),
        array(&amp;#39;CONTENT_TYPE&amp;#39; =&amp;gt; &amp;#39;application/json&amp;#39;),
        &amp;#39;{&amp;quot;title&amp;quot;:&amp;quot;abc&amp;quot;,&amp;quot;body&amp;quot;:&amp;quot;def&amp;quot;}&amp;#39;
    );

    $this-&amp;gt;assertJsonResponse($this-&amp;gt;client-&amp;gt;getResponse(), 204, false);
    $this-&amp;gt;assertTrue(
        $this-&amp;gt;client-&amp;gt;getResponse()-&amp;gt;headers-&amp;gt;contains(
            &amp;#39;Location&amp;#39;,
            sprintf(&amp;#39;http://localhost/api/v1/pages/%d.json&amp;#39;, $page-&amp;gt;getId())
        ),
        $this-&amp;gt;client-&amp;gt;getResponse()-&amp;gt;headers
    );
}

public function testJsonPutPageActionShouldCreate()
{
    $id = 0;
    $this-&amp;gt;client-&amp;gt;request(&amp;#39;GET&amp;#39;, sprintf(&amp;#39;/api/v1/pages/%d.json&amp;#39;, $id), array(&amp;#39;ACCEPT&amp;#39; =&amp;gt; &amp;#39;application/json&amp;#39;));
    $this-&amp;gt;assertEquals(404, $this-&amp;gt;client-&amp;gt;getResponse()-&amp;gt;getStatusCode(), $this-&amp;gt;client-&amp;gt;getResponse()-&amp;gt;getContent());

    $this-&amp;gt;client-&amp;gt;request(
        &amp;#39;PUT&amp;#39;,
        sprintf(&amp;#39;/api/v1/pages/%d.json&amp;#39;, $id),
        array(),
        array(),
        array(&amp;#39;CONTENT_TYPE&amp;#39; =&amp;gt; &amp;#39;application/json&amp;#39;),
        &amp;#39;{&amp;quot;title&amp;quot;:&amp;quot;abc&amp;quot;,&amp;quot;body&amp;quot;:&amp;quot;def&amp;quot;}&amp;#39;
    );

    $this-&amp;gt;assertJsonResponse($this-&amp;gt;client-&amp;gt;getResponse(), 201, false);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the &lt;code&gt;PUT&lt;/code&gt; controller will look like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Update existing page from the submitted data or create a new page at a specific location.
 *
 * @ApiDoc(
 *   resource = true,
 *   input = &amp;quot;Acme\DemoBundle\Form\PageType&amp;quot;,
 *   statusCodes = {
 *     201 = &amp;quot;Returned when the Page is created&amp;quot;,
 *     204 = &amp;quot;Returned when successful&amp;quot;,
 *     400 = &amp;quot;Returned when the form has errors&amp;quot;
 *   }
 * )
 *
 * @Annotations\View(
 *  template = &amp;quot;AcmeBlogBundle:Page:editPage.html.twig&amp;quot;,
 *  templateVar = &amp;quot;form&amp;quot;
 * )
 *
 * @param Request $request the request object
 * @param int     $id      the page id
 *
 * @return FormTypeInterface|View
 *
 * @throws NotFoundHttpException when page not exist
 */
public function putPageAction(Request $request, $id)
{
    try {
        if (!($page = $this-&amp;gt;container-&amp;gt;get(&amp;#39;acme_blog.page.handler&amp;#39;)-&amp;gt;get($id))) {
            $statusCode = Codes::HTTP_CREATED;
            $page = $this-&amp;gt;container-&amp;gt;get(&amp;#39;acme_blog.page.handler&amp;#39;)-&amp;gt;post(
                $request-&amp;gt;request-&amp;gt;all()
            );
        } else {
            $statusCode = Codes::HTTP_NO_CONTENT;
            $page = $this-&amp;gt;container-&amp;gt;get(&amp;#39;acme_blog.page.handler&amp;#39;)-&amp;gt;put(
                $page,
                $request-&amp;gt;request-&amp;gt;all()
            );
        }

        $routeOptions = array(
            &amp;#39;id&amp;#39; =&amp;gt; $page-&amp;gt;getId(),
            &amp;#39;_format&amp;#39; =&amp;gt; $request-&amp;gt;get(&amp;#39;_format&amp;#39;)
        );

        return $this-&amp;gt;routeRedirectView(&amp;#39;api_1_get_page&amp;#39;, $routeOptions, $statusCode);

    } catch (InvalidFormException $exception) {

        return $exception-&amp;gt;getForm();
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The PatchPageAction and the DeletePageAction will be very similar.&lt;/p&gt;

&lt;h3 id='manually_testing_the_lifecycle'&gt;Manually testing the lifecycle&lt;/h3&gt;

&lt;p&gt;We are going to reproduce all the page lifecycle putting the value of the result of the post into a bash variable, so we could reuse.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;location=`curl -X POST -d &amp;#39;{&amp;quot;title&amp;quot;:&amp;quot;liuggio&amp;quot;,&amp;quot;body&amp;quot;:&amp;quot;homepage&amp;quot;}&amp;#39; \
   http://localhost:8000/api/v1/pages.json \
   --header &amp;quot;Content-Type:application/json&amp;quot; -v 2&amp;gt;&amp;amp;1 | grep Location | cut -d \  -f 3`;

echo &amp;quot;created result at: &amp;quot;$location&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the result will look something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;created result at http://localhost:8000/api/v1/pages/143.json&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and we are going to use this $location variable and we will modify the resource:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -X PUT -d &amp;#39;{&amp;quot;title&amp;quot;:&amp;quot;my&amp;quot;,&amp;quot;body&amp;quot;:&amp;quot;homepage&amp;quot;}&amp;#39; $location --header &amp;quot;Content-Type:application/json&amp;quot; -v

curl -X PATCH -d &amp;#39;{&amp;quot;body&amp;quot;:&amp;quot;life&amp;quot;}&amp;#39; $location --header &amp;quot;Content-Type:application/json&amp;quot; -v&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then the get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl $location --header &amp;quot;Content-Type:application/json&amp;quot; &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the result will be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;id&amp;quot;:140,&amp;quot;title&amp;quot;:&amp;quot;my&amp;quot;,&amp;quot;body&amp;quot;:&amp;quot;life&amp;quot;}&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='get_all_the_pages'&gt;GET all the Pages&lt;/h2&gt;

&lt;p&gt;We want to be able to get a list of all the pages, we want to limit the result with pagination.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * List all pages.
 *
 * @ApiDoc(
 *   resource = true,
 *   statusCodes = {
 *     200 = &amp;quot;Returned when successful&amp;quot;
 *   }
 * )
 *
 * @Annotations\QueryParam(name=&amp;quot;offset&amp;quot;, requirements=&amp;quot;\d+&amp;quot;, nullable=true, description=&amp;quot;Offset from which to start listing pages.&amp;quot;)
 * @Annotations\QueryParam(name=&amp;quot;limit&amp;quot;, requirements=&amp;quot;\d+&amp;quot;, default=&amp;quot;5&amp;quot;, description=&amp;quot;How many pages to return.&amp;quot;)
 *
 * @Annotations\View(
 *  templateVar=&amp;quot;pages&amp;quot;
 * )
 *
 * @param Request               $request      the request object
 * @param ParamFetcherInterface $paramFetcher param fetcher service
 *
 * @return array
 */
public function getPagesAction(Request $request, ParamFetcherInterface $paramFetcher)
{
    $offset = $paramFetcher-&amp;gt;get(&amp;#39;offset&amp;#39;);
    $offset = null == $offset ? 0 : $offset;
    $limit = $paramFetcher-&amp;gt;get(&amp;#39;limit&amp;#39;);

    return $this-&amp;gt;container-&amp;gt;get(&amp;#39;acme_blog.page.handler&amp;#39;)-&amp;gt;all($limit, $offset);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using the annotation &lt;code&gt;@Annotations\QueryParam&lt;/code&gt;, is very easy to get the &lt;code&gt;offset&lt;/code&gt;, and &lt;code&gt;limit&lt;/code&gt; that is ORM-ready :).&lt;/p&gt;

&lt;p&gt;This is the &lt;code&gt;PageHandler::all&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Get a list of Pages.
 *
 * @param int $limit  the limit of the result
 * @param int $offset starting from the offset
 *
 * @return array
 */
public function all($limit = 5, $offset = 0, $orderby = null)
{
    return $this-&amp;gt;repository-&amp;gt;findBy(array(), $orderby, $limit, $offset);
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='pagination_with_headers'&gt;Pagination with headers&lt;/h3&gt;

&lt;p&gt;Is possible to include pagination into the headers, there is a RFC: &lt;a href='http://tools.ietf.org/html/rfc5988#page-6'&gt;Link header introduced by RFC 5988&lt;/a&gt;, you could find a good implementation on the &lt;a href='http://developer.github.com/v3/#pagination'&gt;github pagination documentation&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;b&gt;Link Header&lt;/b&gt;&lt;br /&gt;
The pagination info is included in the Link header. It is important to follow these Link header values instead of constructing your own URLs. In some instances, such as in the Commits API, pagination is based on SHA1 and not on page number.&lt;small&gt;github link header&lt;/small&gt;
&lt;/blockquote&gt;
&lt;p&gt;github example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Link: &amp;lt;https://api.github.com/user/repos?page=3&amp;amp;per_page=100&amp;gt;; rel=&amp;quot;next&amp;quot;,&amp;lt;https://api.github.com/user/repos?page=50&amp;amp;per_page=100&amp;gt;; rel=&amp;quot;last&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='symfony2_goodies'&gt;Symfony2 goodies&lt;/h2&gt;

&lt;h3 id='head_method'&gt;HEAD method&lt;/h3&gt;

&lt;p&gt;In Symfony2 the HEAD method follows the same routes and settings of the GET method, if you have the GET method available you will also have the &lt;code&gt;HEAD&lt;/code&gt; that links to the same actions, the response will be empty.&lt;/p&gt;

&lt;h3 id='patching_the_patch_problem'&gt;Patching the PATCH problem&lt;/h3&gt;

&lt;p&gt;Some browser doesn&amp;#8217;t support some methods as &lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;PATCH&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; HTTP methods:&lt;/p&gt;
&lt;blockquote&gt;
    Fortunately Symfony2 provides you with a simple way of working around this limitation.&lt;br /&gt;
     By including a _method parameter in the query string or parameters of an HTTP request,
     Symfony2 will use this as the method when matching routes. &lt;br /&gt;
     Forms automatically include a hidden field for this parameter if their submission method is not GET or POST.&lt;br /&gt;
      See the related chapter in the forms documentation for more information.
    &lt;small&gt;http://symfony.com/doc/current/cookbook/routing/method_parameters.html#faking-the-method-with-method&lt;/small&gt;
&lt;/blockquote&gt;
&lt;h2 id='disable_csrf_with_rest'&gt;Disable CSRF with REST&lt;/h2&gt;

&lt;h3 id='theory_on_crosssite_request_forgery'&gt;Theory on Cross-site request forgery&lt;/h3&gt;

&lt;p&gt;If you don&amp;#8217;t know what CSFR is there is lot of documentation on internet, please have a look to the &lt;a href='http://symfony.com/doc/current/book/forms.html#csrf-protection'&gt;csrf-protection&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
CSRF protection works by adding a hidden field to your form - called _token by default - that contains a value that only you and your user knows. This ensures that the user - not some other entity - is submitting the given data. Symfony automatically validates the presence and accuracy of this token.
&lt;small&gt;http://symfony.com/doc/current/book/forms.html#csrf-protection&lt;/small&gt;
&lt;/blockquote&gt;
&lt;h3 id='csrf_and_rest'&gt;CSRF and REST&lt;/h3&gt;

&lt;p&gt;Is possible to disable the CSRF based on the user&amp;#8217;s role, the documentation on Friend-Of-Symfony repository is self-explanatory: &lt;a href='https://github.com/FriendsOfSymfony/FOSRestBundle/blob/master/Resources/doc/2-the-view-layer.md#CSRF-validation'&gt;FOSRestBundle doc CSRF validation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We need to associate the &lt;code&gt;ROLE_API&lt;/code&gt; to the REST users:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# app/config/security.yml
providers:
    in_memory:
        memory:
            users:
                user:  { password: userpass, roles: [ &amp;#39;ROLE_USER&amp;#39;, &amp;#39;ROLE_API&amp;#39; ] }
                admin: { password: adminpass, roles: [ &amp;#39;ROLE_ADMIN&amp;#39;, &amp;#39;ROLE_API&amp;#39; ] }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then in the config.yml we need to enable the feature&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# app/config/config.yml
fos_rest:
    disable_csrf_role: ROLE_API&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have now to modify the functional tests adding the authentication:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// /src/Acme/BlogBundle/Tests/Controller/PageControllerTest.php
public function setUp()
{
    $this-&amp;gt;auth = array(
        &amp;#39;PHP_AUTH_USER&amp;#39; =&amp;gt; &amp;#39;user&amp;#39;,
        &amp;#39;PHP_AUTH_PW&amp;#39;   =&amp;gt; &amp;#39;userpass&amp;#39;,
    );

    $this-&amp;gt;client = static::createClient(array(), $this-&amp;gt;auth);
}&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='different_points_of_view'&gt;Different points of view&lt;/h2&gt;

&lt;p&gt;It is very common when the API should serves different fields according to the role of the user that requests a resource.&lt;/p&gt;

&lt;p&gt;For example the field &lt;code&gt;state&lt;/code&gt; that determines whether the page is public or not, can only be viewed and changed by the administrator. There are also more complex scenario, eg. the same field may follow different validations.&lt;/p&gt;

&lt;p&gt;How to handle those differences on the same Page Entity?&lt;/p&gt;

&lt;p&gt;There are many ways: validation groups, using serialization groups, or use different forms.&lt;/p&gt;

&lt;h3 id='the_form_is_the_resource'&gt;The form is the resource&lt;/h3&gt;

&lt;p&gt;I personally prefer the form, an idea could be associate a form to a role. Given the same URI, if the user was authenticated as an administrator would use the &lt;code&gt;PageAdminType&lt;/code&gt; form, otherwise she/he would use the &lt;code&gt;PageUserType&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But this idea of associating a form to a role, does not fully comply with the REST philosophy, each request should be made to the desired resource, but technically the forms are different.&lt;/p&gt;

&lt;p&gt;The URI should indicate which resource you want, and the layer of authorization should only accept or reject your request.&lt;/p&gt;

&lt;p&gt;In the article part2, we have already seen that the resource we receive in input is not the entity Page, but it is the &lt;code&gt;pageType&lt;/code&gt; form, the API uses as interface the &lt;code&gt;pageType&lt;/code&gt; form.&lt;/p&gt;

&lt;p&gt;Maybe the best option is use different URIs for different form and role.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;api/v1/pages/&lt;/code&gt;, the form is the standard &lt;code&gt;PageType&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;code&gt;api/v1/admin/pages/&lt;/code&gt; the form used will have more fields and different authentication.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We just apply the definition of Resource not to the Entity but to the form.&lt;/p&gt;

&lt;h2 id='the_perfection'&gt;The perfection?&lt;/h2&gt;

&lt;p&gt;In the enterprise the perfect software is when timing, clean-code and maintenance are in the correct balance with the specifications.&lt;/p&gt;

&lt;p&gt;In the open-source and in the Symfony ecosystem developers tend to do their best, it would be possible to improve our application and our bundle?&lt;/p&gt;

&lt;h3 id='thin_bundle_fat_library'&gt;Thin Bundle, Fat library.&lt;/h3&gt;

&lt;p&gt;We could improve the loose coupling leaving in the bundle only the files that are truly related to Symfony and create a library for the entities, forms and services. But this could be another topic a blog post :).&lt;/p&gt;

&lt;h2 id='recap'&gt;Recap&lt;/h2&gt;

&lt;p&gt;We are in the end of this epic tale, this recapitulate should contain few concepts:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;We have created a smart service &lt;code&gt;PageHandler&lt;/code&gt; where all the logic about the page is.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;The service &lt;code&gt;PageHandler&lt;/code&gt; is an API for all the Symfony application, it respects the Interface &lt;code&gt;PageHandlerInterface&lt;/code&gt;, and is available in the container.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;We have developed a controller &lt;code&gt;PageController&lt;/code&gt;, the actions have @docblock annotations in order to decorate the View, those annotations also create the documentation, and provide a parameters filtering.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;The form is very important in this REST application, the form is the input for our PUT/PATCH/POST methods, it also validates and hydrates the object.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;The form could also be the resource named by the URI.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;We have defined what is the meaning of &lt;code&gt;idempotent&lt;/code&gt; and why &lt;code&gt;PUT&lt;/code&gt; should also create the resource.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;There are a lot of concepts about REST that I won&amp;#8217;t cover here like RESTFul, HAL, OAuth &amp;#8230;&lt;/p&gt;

&lt;p&gt;The &lt;a href='https://github.com/liuggio/symfony2-rest-api-the-best-2013-way'&gt;repository&lt;/a&gt; contains all the functions and the tests that we have seen during those articles.&lt;/p&gt;

&lt;h5 id='have_a_rest'&gt;Have a REST.&lt;/h5&gt;

&lt;p&gt;That is all for the 2013&lt;/p&gt;

&lt;h3 id='resources'&gt;Resources&lt;/h3&gt;

&lt;p&gt;&lt;a href='http://tools.ietf.org/html/rfc1945#page-24'&gt;RFC1945 Request-URI&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://tools.ietf.org/html/rfc5988#page-6'&gt;RFC5988 Web Linking&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://developer.github.com/v3/'&gt;REST API at github.com/v3/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='https://github.com/gimler/symfony-rest-edition'&gt;gimler/symfony rest edition&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://symfony.com/doc/current/cookbook/routing/method_parameters.html#faking-the-method-with-method'&gt;Symfony Faking the Method&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://idbentley.com/blog/2013/03/14/should-restful-apis-include-relationships/'&gt;should-restful-apis-include-relationships/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api'&gt;best-practices-for-a-pragmatic-restful-api&lt;/a&gt;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>part2 - Web API REST with Symfony2</title>
   <link href="http://welcometothebundle.com/web-api-rest-with-symfony2-the-best-way-the-post-method"/>
   <updated>2013-11-16T13:00:00+01:00</updated>
   <id>http://welcometothebundle.com/web-api-rest-with-symfony2-the-best-way-the-post-method</id>
   <content type="html">&lt;h3 id='part_2__the_'&gt;Part 2 - the &lt;code&gt;POST&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;In the &amp;#8217;&lt;a href='http://welcometothebundle.com/symfony2-rest-api-the-best-2013-way/'&gt;Symfony2 REST part 1&lt;/a&gt;&amp;#8217; we created the application, the bundle, we talked about the &lt;code&gt;GET&lt;/code&gt; method, we also talked about the importance of the Interfaces, the content negotiation, and we gave an example of dumb controllers and brain services.&lt;/p&gt;

&lt;p&gt;Here you could find the &lt;a href='/symfony2-rest-api-the-best-way-part-3/'&gt;last article Part3 - The rest of REST&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In this blog post we are going to create a new &lt;code&gt;Page&lt;/code&gt; via &lt;strong&gt;REST API&lt;/strong&gt;: the form is the protagonist of this article.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Edited&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;3/12/2013: Added the Request in the actions, thanks to &lt;a href='http://twitter.com/stloyd'&gt;stloyd&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id='the_github_repository'&gt;The github repository&lt;/h2&gt;

&lt;p&gt;There&amp;#8217;s a repository at &lt;a href='https://github.com/liuggio/symfony2-rest-api-the-best-2013-way/'&gt;liuggio/symfony2-rest-api-the-best-2013-way&lt;/a&gt; you could see the working code using the tag &lt;code&gt;part2&lt;/code&gt; with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;php composer.phar create-project liuggio/symfony2-rest-api-the-best-2013-way blog-rest-symfony2 -sdev
cd blog-rest-symfony2
git checkout -f part2
bin/phpunit -c app&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All the tags for the demo project are at &lt;a href='https://github.com/liuggio/symfony2-rest-api-the-best-2013-way/tags'&gt;tags&lt;/a&gt;, and also you could compare the first 2 articles with &lt;a href='https://github.com/liuggio/symfony2-rest-api-the-best-2013-way/compare/part1...part2'&gt;compare/part1&amp;#8230;part2&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id='httpbang_theory'&gt;HTTP-bang theory&lt;/h2&gt;

&lt;p&gt;Just few concepts to know before coding.&lt;/p&gt;
&lt;blockquote&gt;
Miyagi: Wax on... wax off. Wax on... wax off.
&lt;small&gt;Karate Kid&lt;/small&gt;
&lt;/blockquote&gt;
&lt;h3 id='the_http_methods'&gt;The HTTP Methods&lt;/h3&gt;

&lt;p&gt;The HTTP Methods are well described by &lt;a href='http://developer.github.com/v3/'&gt;github v3 api&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Where possible, API strives to use appropriate HTTP verbs for each action.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;HEAD Can be issued against any resource to get just the HTTP header info.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;GET Used for retrieving resources.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;POST Used for creating resources, or performing custom actions (such as merging a pull request).&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;DELETE Used for deleting resources.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;PATCH Used for updating resources with partial JSON data. For instance, an Issue resource has title and body attributes. A PATCH request may accept one or more of the attributes to update the resource. PATCH is a relatively new and uncommon HTTP Methods.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;PUT Used for replacing resources or collections.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id='safe_and_idempotent'&gt;Safe and idempotent:&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Safe methods&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
    In particular, the convention has been established that the GET and HEAD methods SHOULD NOT have the significance of taking an action other than retrieval. These methods ought to be considered &quot;safe&quot;. This allows user agents to represent other methods, such as POST, PUT and DELETE, in a special way, so that the user is made aware of the fact that a possibly unsafe action is being requested. 
    &lt;small&gt; w3c.org &lt;cite title='Source Title'&gt;w3c-1 w3.org protocols rfc2616-sec9&lt;/cite&gt;&lt;/small&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Idempotent methods&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
    Methods can also have the property of &quot;idempotence&quot; in that (aside from error or expiration issues) the side-effects of N &gt; 0 identical requests is the same as for a single request. The methods GET, HEAD, PUT and DELETE share this property. Also, the methods OPTIONS and TRACE SHOULD NOT have side effects, and so are inherently idempotent.
    &lt;small&gt; w3c.org &lt;cite title='Source Title'&gt;w3c-1 w3.org protocols rfc2616-sec9&lt;/cite&gt;&lt;/small&gt;
&lt;/blockquote&gt;
&lt;p&gt;So idempotent is about the state of the system, if I create a new resource with POST, the state of the system change every time I call the same Post.&lt;/p&gt;

&lt;p&gt;If I delete a resource with $id=10, the system goes always to the same state, so for example multiples and concurrent requests with DELETE pages/10 are accepted without &amp;#8216;side effect&amp;#8217;.&lt;/p&gt;

&lt;p&gt;The Safe methods are very important for HTTP-Caching, and idempontent is about the Request, the response could be different, the code and the message could change.&lt;/p&gt;

&lt;p&gt;You&amp;#8217;d see how the response is about communication and request is about action.&lt;/p&gt;

&lt;h3 id='verbs_and_nouns'&gt;Verbs and nouns&lt;/h3&gt;

&lt;p&gt;Since you want to follow the REST methodology, you should create a web interface, which it uses the HTTP Methods that are available.&lt;/p&gt;

&lt;p&gt;The good practices suggests to use &lt;strong&gt;nouns&lt;/strong&gt; not verbs (this is not really always true we&amp;#8217;ll see in the last part of this trilogy).&lt;/p&gt;

&lt;p&gt;The convention also imposes to use plurals nouns, &lt;code&gt;pages&lt;/code&gt; instead &lt;code&gt;page&lt;/code&gt;, is simpler and coherent.&lt;/p&gt;
&lt;table class='table'&gt;
&lt;thead&gt;
&lt;tr&gt;
    &lt;th&gt;Resource&lt;/th&gt;
    &lt;th&gt;GET&lt;/th&gt;
    &lt;th&gt;POST&lt;/th&gt;
    &lt;th&gt;PUT&lt;/th&gt;
    &lt;th&gt;PATCH&lt;/th&gt;
    &lt;th&gt;DELETE&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
    &lt;td&gt;&lt;b&gt;pages&lt;/b&gt;&lt;/td&gt;
    &lt;td&gt;List of Pages&lt;/td&gt;
    &lt;td&gt;Create a new Page&lt;/td&gt;
    &lt;td&gt;-&lt;/td&gt;
    &lt;td&gt;-&lt;/td&gt;
    &lt;td&gt;[Delete all the pages]*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;&lt;b&gt;pages/{id}&lt;/b&gt;&lt;/td&gt;
    &lt;td&gt;Show pages/10&lt;/td&gt;
    &lt;td&gt;-&lt;/td&gt;
    &lt;td&gt;Update a specific page &lt;br /&gt;[and create if not exists]*&lt;/td&gt;
    &lt;td&gt;Partial update a specific page&lt;/td&gt;
    &lt;td&gt;Delete a specific page&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The &lt;code&gt;POST&lt;/code&gt; should create a new resource, the &lt;code&gt;PUT&lt;/code&gt; should modify an entity.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;PUT&lt;/code&gt; should also create the resource if it not exists, as the definition of &lt;code&gt;idempotent&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But some (quite a lot) web APIs simplify the objective of the PUT (usually they are rubist), giving to it only the update action of a given resource, because is simpler separate the create with &lt;code&gt;POST&lt;/code&gt; and the update with &lt;code&gt;PUT&lt;/code&gt;, but the real difference is well explained by the RFC:&lt;/p&gt;
&lt;blockquote&gt;
    The fundamental difference between the POST and PUT requests is reflected in the different meaning of the Request-URI. The URI in a POST request identifies the resource that will handle the enclosed entity. That resource might be a data-accepting process, a gateway to some other protocol, or a separate entity that accepts annotations. In contrast, the URI in a PUT request identifies the entity enclosed with the request -- the user agent knows what URI is intended and the server MUST NOT attempt to apply the request to some other resource. If the server desires that the request be applied to a different URI,
&lt;/blockquote&gt;
&lt;h3 id='the_actions'&gt;The actions&lt;/h3&gt;

&lt;p&gt;The table below, describes the name of the actions, on the head of the table the HTTP Methods.&lt;/p&gt;
&lt;table class='table'&gt;
&lt;thead&gt;
&lt;tr&gt;
    &lt;th&gt;Resource&lt;/th&gt;
    &lt;th&gt;GET&lt;/th&gt;
    &lt;th&gt;POST&lt;/th&gt;
    &lt;th&gt;PUT&lt;/th&gt;
    &lt;th&gt;PATCH&lt;/th&gt;
    &lt;th&gt;DELETE&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
    &lt;td&gt;&lt;b&gt;pages&lt;/b&gt;&lt;/td&gt;
    &lt;td&gt;List of Pages
&lt;br /&gt;
    getPagesAction()
    &lt;/td&gt;
    &lt;td&gt;Create a new Page&lt;br /&gt;
    postPagesAction()
    &lt;/td&gt;
    &lt;td&gt;-&lt;/td&gt;
    &lt;td&gt;-&lt;/td&gt;
    &lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;&lt;b&gt;pages/{id}&lt;/b&gt;&lt;/td&gt;
    &lt;td&gt;Show
&lt;br /&gt;
    getPageAction($id)&lt;/td&gt;
    &lt;td&gt;-&lt;/td&gt;
    &lt;td&gt;Update
&lt;br /&gt;
    putPageAction($id) &lt;/td&gt;
    &lt;td&gt;Partial update
&lt;br /&gt;
    patchPageAction($id)&lt;/td&gt;
    &lt;td&gt;Delete
&lt;br /&gt;deletePageAction($id)
    &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;So just creating the action properly we will have automatically configured the routes, with the proper HTTP Methods.&lt;/p&gt;

&lt;p&gt;More info at &lt;a href='https://github.com/FriendsOfSymfony/FOSRestBundle/blob/master/Resources/doc/5-automatic-route-generation_single-restful-controller.md#rest-actions'&gt;rest-action fosRestBundle&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id='the_creation'&gt;The creation&lt;/h2&gt;

&lt;p&gt;Back to our Page example, we need a REST API that allows the creation of a Page.&lt;/p&gt;

&lt;h2 id='step_1_writing_the_story'&gt;Step 1 Writing the story&lt;/h2&gt;

&lt;p&gt;The story: calling the resource &lt;code&gt;/api/v1/pages.json&lt;/code&gt; with POST method, and giving the whole serialized content of a &lt;code&gt;Page&lt;/code&gt; entity, the response should have the status code &lt;code&gt;201&lt;/code&gt;, and should be a json response.&lt;/p&gt;

&lt;p&gt;We could easily write this story into a functional test:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// src\Acme\BlogBundle\Tests\Controller\PageControllerTest
public function testJsonPostPageAction()
{
    $this-&amp;gt;client = static::createClient();
    $this-&amp;gt;client-&amp;gt;request(
        &amp;#39;POST&amp;#39;, 
        &amp;#39;/api/v1/pages.json&amp;#39;,  
        array(),
        array(),
        array(&amp;#39;CONTENT_TYPE&amp;#39; =&amp;gt; &amp;#39;application/json&amp;#39;),
        &amp;#39;{&amp;quot;title&amp;quot;:&amp;quot;title1&amp;quot;,&amp;quot;body&amp;quot;:&amp;quot;body1&amp;quot;}&amp;#39;
    );
    $this-&amp;gt;assertJsonResponse($this-&amp;gt;client-&amp;gt;getResponse(), 201, false);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and there is another story:&lt;/p&gt;

&lt;p&gt;calling the resource &lt;code&gt;/api/v1/pages.json&lt;/code&gt; with the POST method, and giving a not valid serialized content of the &lt;code&gt;Page&lt;/code&gt; entity, the response should have the status code &lt;code&gt;400&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function testJsonPostPageActionShouldReturn400WithBadParameters()
{
    $this-&amp;gt;client = static::createClient();
    $this-&amp;gt;client-&amp;gt;request(
        &amp;#39;POST&amp;#39;,
        &amp;#39;/api/v1/pages.json&amp;#39;,
        array(),
        array(),
        array(&amp;#39;CONTENT_TYPE&amp;#39; =&amp;gt; &amp;#39;application/json&amp;#39;),
        &amp;#39;{&amp;quot;ninja&amp;quot;:&amp;quot;turtles&amp;quot;}&amp;#39;
    );

    $this-&amp;gt;assertJsonResponse($this-&amp;gt;client-&amp;gt;getResponse(), 400, false);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course the tests are red, we had to add the &lt;code&gt;post&lt;/code&gt; function in &lt;code&gt;PageHandler&lt;/code&gt; then the &lt;code&gt;postPageAction&lt;/code&gt; in the Controller.&lt;/p&gt;

&lt;p&gt;We are going to create a &lt;code&gt;post&lt;/code&gt; function that takes the parameters (as an array) containing all the fields of the entity &lt;code&gt;Page&lt;/code&gt;,&lt;/p&gt;

&lt;p&gt;the &lt;strong&gt;form&lt;/strong&gt; is responsible to validate and hydrate the new &lt;code&gt;Page&lt;/code&gt; object, then this object is persisted to the Object Manager.&lt;/p&gt;

&lt;h2 id='step_2_the_entity_validation'&gt;Step 2 The Entity validation&lt;/h2&gt;

&lt;p&gt;We have to add the validation layer that will be invisible, the form will perform it automatically:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# src/Acme/BlogBundle/Resources/config/validation.yml
Acme\BlogBundle\Entity\Page:
    properties:
        title:
            - NotBlank: ~
            - NotNull: ~
            - Length:
                min: 2
                max: 50
                minMessage: &amp;quot;Your title must be at least  characters length&amp;quot;
                maxMessage: &amp;quot;Your title name cannot be longer than  characters length&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='step_3_the_pagehandlerpost'&gt;Step 3 The PageHandler::post&lt;/h2&gt;

&lt;p&gt;In the first article we created a service called &lt;code&gt;PageHandler&lt;/code&gt;, its objective is to respect the &lt;code&gt;PageHandlerInterface&lt;/code&gt;, serving the &lt;code&gt;Page&lt;/code&gt; entity with &lt;code&gt;get(id)&lt;/code&gt; and &lt;code&gt;post()&lt;/code&gt;: it could read and write a &lt;code&gt;Page&lt;/code&gt; resource.&lt;/p&gt;

&lt;p&gt;The first step should be create a test that respects the behavior that we want for the post.&lt;/p&gt;

&lt;p&gt;Given parameters containing properties of the &lt;code&gt;Page&lt;/code&gt; like &lt;code&gt;array(&amp;#39;title&amp;#39;=&amp;gt;&amp;#39;title&amp;#39;)&lt;/code&gt; the function should return an already persisted object respecting the interface &lt;code&gt;PageInterface&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id='step_3a_the_post_function'&gt;Step 3.a The post function&lt;/h3&gt;

&lt;p&gt;We are now going to create a function that look like even in the name to the controller&amp;#8217;s function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// src/Acme/BlogBundle/Handler/PageHandler.php
/**
 * Create a new Page.
 *
 * @param array $parameters
 *
 * @return PageInterface
 */
public function post(array $parameters)
{
    $page = $this-&amp;gt;createPage(); // factory method create an empty Page

    // Process form does all the magic, validate and hydrate the Page Object.
    return $this-&amp;gt;processForm($page, $parameters, &amp;#39;POST&amp;#39;);
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='step_3b_the_form_factory'&gt;Step 3.b The form factory&lt;/h3&gt;

&lt;p&gt;In order to use the form we need the &lt;code&gt;form.factory&lt;/code&gt; injected into the service:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// src\Acme\BlogBundle\Handler\PageHandler.php
use Symfony\Component\Form\FormFactoryInterface;
// ...
class PageHandler implements PageHandlerInterface
// ...
private $formFactory;
// ...
public function __construct(ObjectManager $om, $entityClass, FormFactoryInterface $formFactory)
{
    $this-&amp;gt;om = $om;
    $this-&amp;gt;entityClass = $entityClass;
    $this-&amp;gt;repository = $this-&amp;gt;om-&amp;gt;getRepository($this-&amp;gt;entityClass);
    $this-&amp;gt;formFactory = $formFactory;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then we have to add a new argument into the page handler service at &lt;code&gt;/src/Acme/BlogBundle/Resources/config/services.xml&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; ?&amp;gt;
&amp;lt;services&amp;gt;
    &amp;lt;service id=&amp;quot;acme_blog.page.handler&amp;quot; class=&amp;quot;%acme_blog.page.handler.class%&amp;quot;&amp;gt;
        &amp;lt;argument type=&amp;quot;service&amp;quot; id=&amp;quot;doctrine.orm.entity_manager&amp;quot; /&amp;gt;
        &amp;lt;argument&amp;gt;%acme_blog.page.class%&amp;lt;/argument&amp;gt;
        &amp;lt;argument type=&amp;quot;service&amp;quot; id=&amp;quot;form.factory&amp;quot;&amp;gt;&amp;lt;/argument&amp;gt;
    &amp;lt;/service&amp;gt;
&amp;lt;/services&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='step_3c_the_processform'&gt;Step 3.c The processForm&lt;/h3&gt;

&lt;p&gt;It&amp;#8217;s time to back to &lt;code&gt;\Acme\BlogBundle\Handler\PageHandler&lt;/code&gt; and create the &lt;code&gt;processForm&lt;/code&gt; function, the hearth of the write functions.&lt;/p&gt;

&lt;p&gt;You have surely already used &lt;a href='http://api.symfony.com/2.3/Symfony/Component/Form/FormInterface.html'&gt;form-&amp;gt;handleRequest($request)&lt;/a&gt;, but in this case we don&amp;#8217;t have the Request but only the values ​​ in an array, so instead of &lt;code&gt;handleRequest&lt;/code&gt;, we are going to &lt;code&gt;submit&lt;/code&gt; the form.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Processes the form.
 *
 * @param PageInterface $page
 * @param array         $parameters
 * @param String        $method
 *
 * @return PageInterface
 *
 * @throws \Acme\BlogBundle\Exception\InvalidFormException
 */
private function processForm(PageInterface $page, array $parameters, $method = &amp;quot;PUT&amp;quot;)
{
    $form = $this-&amp;gt;formFactory-&amp;gt;create(new PageType(), $page, array(&amp;#39;method&amp;#39; =&amp;gt; $method));
    $form-&amp;gt;submit($parameters, &amp;#39;PATCH&amp;#39; !== $method);
    if ($form-&amp;gt;isValid()) {

        $page = $form-&amp;gt;getData();
        $this-&amp;gt;om-&amp;gt;persist($page);
        $this-&amp;gt;om-&amp;gt;flush($page);

        return $page;
    }

    throw new InvalidFormException(&amp;#39;Invalid submitted data&amp;#39;, $form);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This function returns an object of &lt;code&gt;PageInterface&lt;/code&gt; type, but if the parameters are not valid it throws an &lt;code&gt;InvalidFormException&lt;/code&gt; that will be handled and caught by the controller.&lt;/p&gt;

&lt;p&gt;The test class is at &lt;a href='https://github.com/liuggio/symfony2-rest-api-the-best-2013-way/blob/part2/src/Acme/BlogBundle/Tests/Handler/PageHandlerTest.php/'&gt;part2-src/Acme/BlogBundle/Tests/Handler/PageHandlerTest.php&lt;/a&gt;&lt;/p&gt;

&lt;h3 id='why_dont_use_the_request'&gt;Why don&amp;#8217;t use the request?&lt;/h3&gt;

&lt;p&gt;The real question is: do we really need the request here?&lt;/p&gt;

&lt;p&gt;The answer is &lt;strong&gt;no&lt;/strong&gt;, the main responsibility of &lt;code&gt;PageHandler&lt;/code&gt; class is to &lt;code&gt;handle&lt;/code&gt; (creating, editing, showing) the &lt;code&gt;Page&lt;/code&gt; entity, given some parameters, it doesn&amp;#8217;t care about Request.&lt;/p&gt;

&lt;p&gt;In this way you could use &lt;code&gt;PageHandler&lt;/code&gt; from container services, without injecting or faking the Request.&lt;/p&gt;

&lt;p&gt;In the end of this series of articles you will have an application that serves REST API,&lt;/p&gt;

&lt;p&gt;but the PageHandler is itself an API, usable by services of your application via service container.&lt;/p&gt;

&lt;h2 id='step_4_the_post_and_the_controller'&gt;Step 4 The POST and the Controller&lt;/h2&gt;

&lt;h3 id='the_function'&gt;The function&lt;/h3&gt;

&lt;p&gt;The postPageAction is simple, all the domain logic is demanded to the &lt;code&gt;PageHandler&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Create a Page from the submitted data.
 *
 * @ApiDoc(
 *   resource = true,
 *   description = &amp;quot;Creates a new page from the submitted data.&amp;quot;,
 *   input = &amp;quot;Acme\BlogBundle\Form\PageType&amp;quot;,
 *   statusCodes = {
 *     200 = &amp;quot;Returned when successful&amp;quot;,
 *     400 = &amp;quot;Returned when the form has errors&amp;quot;
 *   }
 * )
 *
 * @Annotations\View(
 *  template = &amp;quot;AcmeBlogBundle:Page:newPage.html.twig&amp;quot;,
 *  statusCode = Codes::HTTP_BAD_REQUEST,
 *  templateVar = &amp;quot;form&amp;quot;
 * )
 *
 * @param Request $request the request object
 *
 * @return FormTypeInterface|View
 */
public function postPageAction(Request $request)
{
   try {
       // Hey Page handler create a new Page.
       $newPage = $this-&amp;gt;container-&amp;gt;get(&amp;#39;acme_blog.page.handler&amp;#39;)-&amp;gt;post(
           $request-&amp;gt;request-&amp;gt;all()
       );

       $routeOptions = array(
           &amp;#39;id&amp;#39; =&amp;gt; $newPage-&amp;gt;getId(),
           &amp;#39;_format&amp;#39; =&amp;gt; $request-&amp;gt;get(&amp;#39;_format&amp;#39;)
       );

       return $this-&amp;gt;routeRedirectView(&amp;#39;api_1_get_page&amp;#39;, $routeOptions, Codes::HTTP_CREATED);
   } catch (InvalidFormException $exception) {

       return $exception-&amp;gt;getForm();
   }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='the_location'&gt;The location&lt;/h3&gt;

&lt;p&gt;A new page is created by the &lt;code&gt;PageHandler&lt;/code&gt;, then the helper &lt;code&gt;routeRedirectView&lt;/code&gt; adds to the http header the location: &lt;code&gt;http://localhost:8000/api/v1/pages/47.json&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id='the_template'&gt;The template&lt;/h3&gt;

&lt;p&gt;Remember to create the template newPage.html.twig something like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/src/Acme/BlogBundle/Resources/views/Page/newPage.html.twig
&amp;lt;h1&amp;gt;Page Form&amp;lt;/h1&amp;gt;
&amp;lt;form action=&amp;quot;{ { url(&amp;#39;api_1_post_page&amp;#39;) } }&amp;quot; method=&amp;quot;POST&amp;quot; { { form_enctype(form) } }&amp;gt;
    { { form_widget(form) } }
    &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;submit&amp;quot;&amp;gt;
&amp;lt;/form&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='the_api'&gt;The API&lt;/h3&gt;

&lt;p&gt;Maybe it has gone unnoticed but in the annotation of the documentation, the input of the post is not the &lt;code&gt;Page&lt;/code&gt; object but a form type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* @ApiDoc(
*   ...
*   input = &amp;quot;Acme\BlogBundle\Form\PageType&amp;quot;,
*   ...&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;#8217;d see how much the form is important in our API application.&lt;/p&gt;

&lt;h3 id='the_name_of_the_form_type'&gt;The name of the Form type&lt;/h3&gt;

&lt;p&gt;One thing that seems very obscure in the eyes of those doing the rest with the form is the &lt;code&gt;getName&lt;/code&gt;,&lt;/p&gt;

&lt;p&gt;in all the examples above we sent all the data with an empty &lt;code&gt;PageType::name&lt;/code&gt; but if we&amp;#8217;d change to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// src/Acme/BlogBundle/Form/PageType.php
/**
 * @return string
 */
public function getName()
{
    return &amp;#39;page&amp;#39;;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The data should be sent with a different syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -X POST -d &amp;#39;{&amp;quot;page&amp;quot;:{&amp;quot;title&amp;quot;:&amp;quot;title1&amp;quot;,&amp;quot;body&amp;quot;:&amp;quot;body1&amp;quot;}}&amp;#39; http://localhost:8000/api/v1/pages.json --header &amp;quot;Content-Type:application/json&amp;quot; -v&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the controller should look something like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function postPageAction(Request $request)
{
    try {
        $form = new PageType();
        $newPage = $this-&amp;gt;container-&amp;gt;get(&amp;#39;acme_blog.page.handler&amp;#39;)-&amp;gt;post(
                $request-&amp;gt;request-&amp;gt;get($form-&amp;gt;getName())
        );
// ...&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='rest_is_also_for_human'&gt;Rest is (also) for human&lt;/h2&gt;

&lt;h3 id='people_and_rest_got_the_power'&gt;People (and REST) got the power&lt;/h3&gt;

&lt;p&gt;There are many protocols and each has its advantages and its reasons, SOAP, XML-RPC. The added value of REST is that it is not just for client API and web browser is &lt;strong&gt;for people too&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id='conventional_actions'&gt;Conventional Actions&lt;/h2&gt;

&lt;p&gt;The title &lt;code&gt;Rest is also for human&lt;/code&gt; is self explanatory and the guys at Friends Of Symfony, wrote how to increase the interaction with the REST process, adding some &lt;code&gt;conventional actions&lt;/code&gt;:&lt;/p&gt;
&lt;blockquote&gt;
HATEOAS, or Hypermedia as the Engine of Application State, is an aspect of REST which allows clients to interact with the REST service with hypertext - most commonly through an HTML page. There are 3 Conventional Action routings that are supported by this bundle: 

&lt;b&gt;new&lt;/b&gt;, &lt;b&gt;edit&lt;/b&gt;, &lt;b&gt;remove&lt;/b&gt; ... from FOSREST-1
&lt;/blockquote&gt;
&lt;h2 id='step_5_the_newpage_action'&gt;Step 5 The newPage action&lt;/h2&gt;

&lt;p&gt;We are going to create the new action:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;new&lt;/strong&gt; - A hypermedia representation that acts as the engine to POST. Typically this is a form that allows the client to POST a new resource. Shown as PageController::newPagesAction()&lt;/p&gt;

&lt;p&gt;We are providing a REST API for &lt;code&gt;json&lt;/code&gt;, &lt;code&gt;xml&lt;/code&gt;, and &lt;code&gt;html&lt;/code&gt; formats, so a user could be able to create a correct request, we should provide also a web page to create the form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Presents the form to use to create a new page.
 *
 * @ApiDoc(
 *   resource = true,
 *   statusCodes = {
 *     200 = &amp;quot;Returned when successful&amp;quot;
 *   }
 * )
 *
 * @Annotations\View()
 *
 * @return FormTypeInterface
 */
public function newPageAction()
{
    return $this-&amp;gt;createForm(new PageType());
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Automatically a new route is added at &lt;code&gt;/api/v1/pages/new.{_format}&lt;/code&gt; you could check it with&lt;/p&gt;

&lt;p&gt;&lt;code&gt;app/console router:debug | grep api&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Accessing to the the page with &lt;code&gt;curl -S localhost:8000/api/v1/pages/new&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;you will obtain a working html form.&lt;/p&gt;

&lt;h2 id='manually_test_the_application'&gt;Manually test the application&lt;/h2&gt;

&lt;h3 id='the_happy_path_201'&gt;The happy path 201&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;curl -X POST -d &amp;#39;{&amp;quot;title&amp;quot;:&amp;quot;title&amp;quot;,&amp;quot;body&amp;quot;:&amp;quot;body&amp;quot;}&amp;#39; http://localhost:8000/api/v1/pages.json --header &amp;quot;Content-Type:application/json&amp;quot; &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It will return&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt; HTTP/1.1 201 Created
&amp;lt; Host: localhost:8000
&amp;lt; Location: http://localhost:8000/api/v1/pages/50.json
&amp;lt; Allow: POST
&amp;lt; Content-Type: application/json&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is great! HTTP Status code &lt;code&gt;201&lt;/code&gt; resource created, and location tells to the consumers where to get this resource.&lt;/p&gt;

&lt;h3 id='bad_parameters_400'&gt;Bad parameters 400&lt;/h3&gt;

&lt;p&gt;Let&amp;#8217;s try to send a bad content:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -X POST -d &amp;#39;{&amp;quot;ninja&amp;quot;:&amp;quot;title&amp;quot;,&amp;quot;turtles&amp;quot;:&amp;quot;body&amp;quot;}&amp;#39; http://localhost:8000/api/v1/pages.json --header &amp;quot;Content-Type:application/json&amp;quot; -v&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Response will be &lt;code&gt;400&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt; HTTP/1.1 400 Bad Request
&amp;lt; Host: localhost:8000
&amp;lt; Content-Type: application/json
&amp;lt; 
&amp;lt; {&amp;quot;form&amp;quot;:{&amp;quot;errors&amp;quot;:[&amp;quot;This form should not contain extra fields.&amp;quot;],&amp;quot;children&amp;quot;:{&amp;quot;title&amp;quot;:[],&amp;quot;body&amp;quot;:[]}}}&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='things_to_know_and_not_always_to_do'&gt;Things to know (and not always to do)&lt;/h2&gt;

&lt;p&gt;There are simple steps that could improve a little bit the project:&lt;/p&gt;

&lt;h3 id='the_nonproblem'&gt;The non-problem&lt;/h3&gt;

&lt;p&gt;Do you remember how we used the formFactory in the PageHandler?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// src\Acme\BlogBundle\Handler\PageHandler::$formFactory
$form = $this-&amp;gt;formFactory-&amp;gt;create(new PageType(), $page, array(&amp;#39;method&amp;#39; =&amp;gt; $method));&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and do you remember how we created the PageType?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// src/Acme/BlogBundle/Form/PageType.php
&amp;#39;data_class&amp;#39; =&amp;gt; &amp;#39;Acme\BlogBundle\Entity\Page&amp;#39;,&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We hardcoded the classes inside another class, we create an hard dependency.&lt;/p&gt;

&lt;h3 id='the_solution'&gt;The solution&lt;/h3&gt;

&lt;p&gt;we could create the PageType as service, and use the name of the service from the PageHandler.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;parameter key=&amp;quot;acme_blog.page.type.class&amp;quot;&amp;gt;Acme\BlogBundle\Form\PageType&amp;lt;/parameter&amp;gt;
&amp;lt;parameter key=&amp;quot;acme_blog.page.type.name&amp;quot;&amp;gt;&amp;lt;/parameter&amp;gt;
&amp;lt;parameter key=&amp;quot;acme_blog.page.type.alias&amp;quot;&amp;gt;leaphly_cart&amp;lt;/parameter&amp;gt;

&amp;lt;service id=&amp;quot;acme_blog.page.type&amp;quot; class=&amp;quot;Leaphly\CartBundle\Form\Type\CartFormType&amp;quot;&amp;gt;
    &amp;lt;argument&amp;gt;%acme_blog.page.type.class%&amp;lt;/argument&amp;gt;
    &amp;lt;tag name=&amp;quot;form.type&amp;quot; alias=&amp;quot;%acme_blog.page.type.alias%&amp;quot; /&amp;gt;
&amp;lt;/service&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then in the &lt;code&gt;Page handler&lt;/code&gt; do something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$this-&amp;gt;formFactory-&amp;gt;createNamed ...&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the code given on github &lt;strong&gt;doesn&amp;#8217;t cover&lt;/strong&gt; the form type as service.&lt;/p&gt;

&lt;h3 id='justifying_this_extra_effort'&gt;Justifying this extra effort&lt;/h3&gt;

&lt;p&gt;In few cases this could be considered an &lt;a href='http://en.wikipedia.org/wiki/Overengineering'&gt;over-engineered&lt;/a&gt; task,&lt;/p&gt;

&lt;p&gt;but when the form type needs extra powers(eg. database access) or when we want to remove all the hard-coding and explicit classes, or if we want to centralize the parameters and the classes in order to be easily changed or renamed, the form type as service could be useful.&lt;/p&gt;

&lt;h2 id='the_documentation_as_bonus'&gt;The documentation as bonus&lt;/h2&gt;

&lt;p&gt;With &lt;a href='https://github.com/nelmio/NelmioApiDocBundle'&gt;NelmioApiDocBundle&lt;/a&gt; we will have a documentation &lt;strong&gt;for free&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;adding a route:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# app/config/routing.yml
NelmioApiDocBundle:
    resource: &amp;quot;@NelmioApiDocBundle/Resources/config/routing.yml&amp;quot;
    prefix:   /api/doc&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then modifying the PostAction annotations&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * @ApiDoc(
 *   resource = true,
 *   description = &amp;quot;Creates a new page from the submitted data.&amp;quot;,
 *   input = &amp;quot;Acme\BlogBundle\Form\PageType&amp;quot;,
 *   statusCodes = {
 *     200 = &amp;quot;Returned when successful&amp;quot;,
 *     400 = &amp;quot;Returned when the form has errors&amp;quot;
 *   }
 * )
 */
public function postPageAction&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And thanks to &lt;a href='https://github.com/nelmio/NelmioApiDocBundle/graphs/contributors'&gt;this guys&lt;/a&gt; you will have something like:&lt;/p&gt;

&lt;p&gt;&lt;img src='/assets/themes//readable-liuggio/img/screenshot-nelmio.png' alt='NelmioApiDocBundle screen-shot' /&gt;&lt;/p&gt;

&lt;h2 id='recap'&gt;Recap&lt;/h2&gt;

&lt;p&gt;Now we could create and read a resource via HTTP REST, using those routes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;api_1_get_page           GET    ANY    ANY  /api/v1/pages/{id}.{_format}
api_1_new_page           GET    ANY    ANY  /api/v1/pages/new.{_format}
api_1_post_page          POST   ANY    ANY  /api/v1/pages.{_format}
nelmio_api_doc_index     GET    ANY    ANY  /api/doc/&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also have created another API usable via service container and the API are defined into the &lt;code&gt;PageHandlerInterface&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// src/Acme/BlogBundle/Handler/PageHandlerInterface.php
interface PageHandlerInterface
{
    /**
     * Get a Page given the identifier
     *
     * @api
     *
     * @param int $id
     *
     * @return PageInterface
     */
    public function get($id);

    /**
     * Post Page, creates a new Page.
     *
     * @api
     *
     * @param array $parameters
     *
     * @return PageInterface
     */
    public function post(array $parameters);
}&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='next__the_last_rest_api_episode'&gt;Next ›› &lt;a href='/symfony2-rest-api-the-best-way-part-3/'&gt;The last REST API episode&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;In the next articles, we will describe how to delete, edit partially and totally a resource with &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;PATCH&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt;, we will talk how use other important HTTP headers, we will play with &lt;code&gt;filter&lt;/code&gt; &amp;#8230;&lt;/p&gt;

&lt;h3 id='references'&gt;References&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href='http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html'&gt;W3C-1 w3.org/Protocols/rfc2616/rfc2616-sec9&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://zachholman.com/2010/03/the-human-is-a-restful-client/'&gt;ZAC-1 - Zach Holman: The Human is a RESTful Client&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='https://github.com/FriendsOfSymfony/FOSRestBundle/blob/master/Resources/doc/5-automatic-route-generation_single-restful-controller.md#conventional-actions'&gt;FOSREST-1 conventional-actions&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://symfony.com/doc/current/cookbook/form/direct_submit.html'&gt;symfony.com/doc/current/cookbook/form/direct_submit.html&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://symfony.com/doc/current/cookbook/form/create_custom_field_type.html'&gt;symfony.com/doc/current/cookbook/form/create_custom_field_type.html&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='https://github.com/nelmio/NelmioApiDocBundle'&gt;NelmioApiDocBundle&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='https://github.com/lsmith77/symfony-rest-edition/'&gt;lsmith77/symfony-rest-edition/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content>
 </entry>
 
 <entry>
   <title>Symfony2 REST API: the best way</title>
   <link href="http://welcometothebundle.com/symfony2-rest-api-the-best-2013-way"/>
   <updated>2013-11-13T13:00:00+01:00</updated>
   <id>http://welcometothebundle.com/symfony2-rest-api-the-best-2013-way</id>
   <content type="html">&lt;h3 id='part_1__the_'&gt;Part 1 - the &lt;code&gt;GET&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Here&amp;#8217;s another nice guide on how to create an API with Symfony2, this is the &lt;strong&gt;part 1&lt;/strong&gt; of a series of articles.&lt;/p&gt;

&lt;p&gt;Here you could find the &lt;a href='/web-api-rest-with-symfony2-the-best-way-the-post-method/'&gt;Part2 - the &amp;#8216;POST&amp;#8217;&lt;/a&gt;, and the last article &lt;a href='/symfony2-rest-api-the-best-way-part-3/'&gt;Part3 - The rest of REST&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I would like to be short and concise bringing practical examples.&lt;/p&gt;

&lt;p&gt;I would not talk about the difference between REST and RESTful &lt;a href='http://martinfowler.com/articles/richardsonMaturityModel.html'&gt;Martin Fowler Maturity Model&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The title of this series is just because I&amp;#8217;ve found a lot of great ideas from the &lt;a href='http://williamdurand.fr/2012/08/02/rest-apis-with-symfony2-the-right-way/'&gt;William Durand: rest-apis-with-symfony2-the-right-way&lt;/a&gt; blog written in 2012, so this is a revisited version, talking more about form, and services.&lt;/p&gt;

&lt;h2 id='motivation'&gt;Motivation&lt;/h2&gt;

&lt;p&gt;Writing Leaphly &lt;a href='http://leaphly.org'&gt;symfony cart rest&lt;/a&gt; we had few problems finding a tutorial or a blog post that could show us how to properly use REST and symfony2 with forms and doctrine.&lt;/p&gt;

&lt;h2 id='goal'&gt;GOAL&lt;/h2&gt;

&lt;p&gt;We are going to create an application that serves API for Page content with &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;post&lt;/code&gt; and &lt;code&gt;patch&lt;/code&gt;, using &lt;a href='http://www.symfony2.com'&gt;Symfony2&lt;/a&gt;, the &lt;a href='https://github.com/FriendsOfSymfony/FOSRestBundle'&gt;FOSRestBundle&lt;/a&gt;, the &lt;a href='https://github.com/nelmio/NelmioApiDocBundle'&gt;NelmioApiDocBundle&lt;/a&gt;, the &lt;a href='https://github.com/schmittjoh/JMSSerializerBundle'&gt;JSMSerializerBundle&lt;/a&gt;, and &lt;a href='http://www.doctrine-project.org'&gt;Doctrine&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The real objective is create an application that shows some best practices and rules with Symfony2 and REST:&lt;/p&gt;

&lt;h3 id='rules'&gt;Rules&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Interface as contracts.&lt;/li&gt;

&lt;li&gt;Thin Controller, Fat Service.&lt;/li&gt;

&lt;li&gt;The &lt;code&gt;Content Negotiation&lt;/code&gt; in the HTTP and REST.&lt;/li&gt;

&lt;li&gt;Form as API interface.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id='the_github_repository'&gt;The github repository&lt;/h2&gt;

&lt;p&gt;There&amp;#8217;s a repository at &lt;a href='https://github.com/liuggio/symfony2-rest-api-the-best-2013-way/'&gt;liuggio/symfony2-rest-api-the-best-2013-way&lt;/a&gt; you could see the working code using the tag &lt;code&gt;part1&lt;/code&gt; with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;php composer.phar create-project liuggio/symfony2-rest-api-the-best-2013-way blog-rest-symfony2 -sdev
cd blog-rest-symfony2
git checkout -f part1
bin/phpunit -c app&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All the tags for the demo project at &lt;a href='https://github.com/liuggio/symfony2-rest-api-the-best-2013-way/tags'&gt;tags&lt;/a&gt;&lt;/p&gt;

&lt;h2 id='step_1a_the_application'&gt;Step 1.A The application&lt;/h2&gt;

&lt;p&gt;Create a Symfony application&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;php composer.phar create-project symfony/framework-standard-edition BlogRESTAPI/
cd BlogRESTAPI
php composer.phar require &amp;quot;friendsofsymfony/rest-bundle&amp;quot; &amp;quot;@dev&amp;quot;
php composer.phar require &amp;quot;jms/serializer-bundle&amp;quot; &amp;quot;@dev&amp;quot;
php composer.phar require &amp;quot;nelmio/api-doc-bundle&amp;quot; &amp;quot;@dev&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then we had to configure the bundles properly and add to the appKernel.php&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// app/AppKernel.php
$bundles = array(
    //..
    new FOS\RestBundle\FOSRestBundle(),
    new JMS\SerializerBundle\JMSSerializerBundle(),
    new Nelmio\ApiDocBundle\NelmioApiDocBundle(),&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='step_1b_the_blog_bundle'&gt;Step 1.B The Blog Bundle&lt;/h2&gt;

&lt;p&gt;We are going to create a REST controller for the Page Entity, in your symfony2 standard application we need to create the bundle:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app/console generate:bundle --namespace=Acme/BlogBundle --dir=src --no-interaction&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='step_1c_the_model'&gt;Step 1.C The Model&lt;/h2&gt;

&lt;p&gt;We are going to create an Entity called &lt;code&gt;Page&lt;/code&gt; with &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;body&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;php app/console doctrine:generate:entity --entity=AcmeBlogBundle:Page \
  --format=annotation --fields=&amp;quot;title:string(255) body:text&amp;quot; \
  --no-interaction
php app/console doctrine:database:create
php app/console doctrine:schema:create&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='step_1d_the_page_form'&gt;Step 1.D The Page Form&lt;/h2&gt;

&lt;p&gt;Now we need the form for that entity, another generator command :)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;php app/console doctrine:generate:form AcmeBlogBundle:Page --no-interaction&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='step_2__start_with_rest'&gt;Step 2 - Start with Rest&lt;/h2&gt;

&lt;h3 id='step_2a__the_functional_test'&gt;Step 2.A - The functional test&lt;/h3&gt;

&lt;p&gt;We want to create a function that when it&amp;#8217;s called it returns the resource with the format requested.&lt;/p&gt;

&lt;p&gt;Any good controller should start with a Functional test, but in order to reduce the verbosity I&amp;#8217;ll talk about functional test later, see the section 3.C below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. /api/v1/pages/{id}.{_format}
2. /api/v1/pages/{id}.json  # will return a json file
3. /api/v1/pages/{id}.xml   # will return a xml file
4. /api/v1/pages/{id} and /api/1/pages/{id}.html  # will return the web page file&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;#8217;ll see later how to not explicitly specify the format, and how to use and set-up correctly the content-negotiation using HTTP Headers.&lt;/p&gt;

&lt;h3 id='step_2b__the_controller'&gt;Step 2.B - The controller&lt;/h3&gt;

&lt;p&gt;We want to create the controller class&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// /src/Acme/BlogBundle/Controller/PageController.php
class PageController extends FOSRestController&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then we add a simple and dirty function (we&amp;#8217;ll refactor soon)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function getPageAction($id)
{
    return $this-&amp;gt;container-&amp;gt;get(&amp;#39;doctrine.entity_manager&amp;#39;)-&amp;gt;getRepository(&amp;#39;Page&amp;#39;)-&amp;gt;find($id);
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id='edit14112013_samuel_gordalina_suggests'&gt;&lt;strong&gt;&lt;span&gt;EDIT-14/11/2013&lt;/span&gt;&lt;/strong&gt; Samuel Gordalina suggests:&lt;/h4&gt;

&lt;p&gt;You can use ParamConverter which fetches an entity from database or returns a 404 exception. For more info see &lt;a href='https://github.com/gordalina/sample-twitter-api-symfony2/blob/master/src/Twitter/ApiBundle/Controller/TweetController.php#L37'&gt;sample-twitter-api-symfony2:37&lt;/a&gt;&lt;/p&gt;

&lt;h3 id='step_2c__adding_the_routes'&gt;Step 2.C - Adding the routes&lt;/h3&gt;

&lt;p&gt;Add to the route file&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# /app/config/routing.yml
acme_blog:
    type: rest
    prefix: /api
    resource: &amp;quot;@AcmeBlogBundle/Resources/config/routes.yml&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create a route file into the bundle:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# /src/Acme/BlogBundle/Resources/config/routes.yml
acme_blog_Page:
    type: rest
    prefix: /v1
    resource: &amp;quot;Acme\BlogBundle\Controller\PageController&amp;quot;
    name_prefix:  api_1_ # naming collision&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;check all the API routes with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app/console route:debug | grep api&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it should contain the &lt;code&gt;api_1_get_page&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;So we now have a route, and a controller that responses to the get(id) with the Page resource, is that what we wanted?&lt;/p&gt;

&lt;p&gt;Yes but we could do better.&lt;/p&gt;

&lt;h2 id='step_3__refactoring'&gt;Step 3 - Refactoring&lt;/h2&gt;

&lt;p&gt;OMG we have only created a little Controller, why we need to refactor?&lt;/p&gt;

&lt;p&gt;As I said we are trying to do things at our best, while this may seem over-engineering, in later articles we will see how take advantage of the changes made.&lt;/p&gt;

&lt;h3 id='step_3a__interface_as_contract'&gt;Step 3.A - Interface as contract&lt;/h3&gt;
&lt;blockquote&gt;
Type hinting the injected object means that you can be sure that a suitable dependency has been injected.
By type-hinting, you'll get a clear error immediately if an unsuitable dependency is injected.
By type hinting using an interface rather than a class you can make the choice of dependency more flexible.
And assuming you only use methods defined in the interface, you can gain that flexibility and still safely use the object.
 &lt;small&gt; from &lt;cite title='Source Title'&gt;sf2 - symfony.com&lt;/cite&gt;&lt;/small&gt;
&lt;/blockquote&gt;
&lt;p&gt;Following this as first rule, we need to create an interface in &lt;code&gt;/src/Acme/BlogBundle/Model/PageInterface.php&lt;/code&gt; and then put &lt;code&gt;implements PageInterface&lt;/code&gt; in the entity &lt;code&gt;Page&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id='step_3b__the_page_handler'&gt;Step 3.B - The Page Handler&lt;/h3&gt;

&lt;p&gt;In order to remove all the logic from the &lt;code&gt;PageController&lt;/code&gt;, we have to create a service, we call it &lt;code&gt;PageHandler&lt;/code&gt; in &lt;code&gt;/src/Acme/BlogBundle/Handler/PageHandler.php&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The test for the the &lt;code&gt;PageHandler&lt;/code&gt; looks something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// /src/Acme/BlogBundle/Tests/Handler/PageHandlerTest.php:45
public function testGet()
{
    $id = 1;
    $page = $this-&amp;gt;getPage(); // create a Page object
    // I expect that the Page repository is called with find(1)
    $this-&amp;gt;repository-&amp;gt;expects($this-&amp;gt;once())
        -&amp;gt;method(&amp;#39;find&amp;#39;)
        -&amp;gt;with($this-&amp;gt;equalTo($id))
        -&amp;gt;will($this-&amp;gt;returnValue($page));

    $this-&amp;gt;pageHandler-&amp;gt;get($id); // call the get.
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So it uses &lt;code&gt;find&lt;/code&gt; to fetch an &lt;code&gt;id&lt;/code&gt; using the doctrine repository.&lt;/p&gt;

&lt;p&gt;We are going to create the effective &amp;#8216;Handler&amp;#8217; that will manage all the transactions to the persistence layer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// /src/Acme/BlogBundle/Handler/PageHandler.php:16
class PageHandler implements PageHandlerInterface
{
    // ..
    public function __construct(ObjectManager $om, $entityClass)
    {
        $this-&amp;gt;om = $om;
        $this-&amp;gt;entityClass = $entityClass;
        $this-&amp;gt;repository = $this-&amp;gt;om-&amp;gt;getRepository($this-&amp;gt;entityClass);
    }

    // ...
    public function get($id)
    {
        return $this-&amp;gt;repository-&amp;gt;find($id);
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We need to make this class available as a service from the dependency injection:&lt;/p&gt;

&lt;p&gt;/src/Acme/BlogBundle/Resources/config/services.xml&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;parameters&amp;gt;
    &amp;lt;parameter key=&amp;quot;acme_blog.page.handler.class&amp;quot;&amp;gt;Acme\BlogBundle\Handler\PageHandler&amp;lt;/parameter&amp;gt;
    &amp;lt;parameter key=&amp;quot;acme_blog.page.class&amp;quot;&amp;gt;Acme\BlogBundle\Entity\Page&amp;lt;/parameter&amp;gt;
&amp;lt;/parameters&amp;gt;

&amp;lt;services&amp;gt;
    &amp;lt;service id=&amp;quot;acme_blog.page.handler&amp;quot; class=&amp;quot;%acme_blog.page.handler.class%&amp;quot;&amp;gt;
        &amp;lt;argument type=&amp;quot;service&amp;quot; id=&amp;quot;doctrine.orm.entity_manager&amp;quot; /&amp;gt;
        &amp;lt;argument&amp;gt;%acme_blog.page.class%&amp;lt;/argument&amp;gt;
    &amp;lt;/service&amp;gt;
&amp;lt;/services&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='step_3c__thin_controller'&gt;Step 3.C - Thin Controller&lt;/h3&gt;

&lt;p&gt;Now we have to refactor the controller in order to follow the modification above and use the &lt;code&gt;PageHandler&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id='the_functional_test_for_the_controller'&gt;The functional test for the controller:&lt;/h4&gt;

&lt;p&gt;first add to your &lt;code&gt;composer.json&lt;/code&gt; the require-dev section:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;require-dev&amp;quot;: {
    &amp;quot;doctrine/doctrine-fixtures-bundle&amp;quot;: &amp;quot;dev-master&amp;quot;,
    &amp;quot;phpunit/phpunit&amp;quot;: &amp;quot;3.7.*&amp;quot;,
    &amp;quot;liip/functional-test-bundle&amp;quot;:&amp;quot;dev-master&amp;quot;
},&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then we have to update the dependencies running &lt;code&gt;php composer.phar update&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;There&amp;#8217;s a lot to say about the functional test, we are going to test that when the &lt;code&gt;api_1_get_page&lt;/code&gt; is called, it should return a response with &lt;code&gt;200&lt;/code&gt;, the type of the content should be &lt;code&gt;json&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;liip/functional-test-bundle&lt;/code&gt; helps us to handle the fixtures data to the persistence layer before each test.&lt;/p&gt;

&lt;p&gt;First we configure &lt;code&gt;fos_rest&lt;/code&gt; in order to handle correct format see: &lt;code&gt;/app/config/config.yml:69&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;We have to create the fixture class see &lt;code&gt;/src/Acme/BlogBundle/Tests/Fixtures/Entity/LoadPageData.php&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;and the test:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function testGet()
{
    $fixtures = array(&amp;#39;Acme\BlogBundle\Tests\Fixtures\Entity\LoadPageData&amp;#39;);
    $this-&amp;gt;customSetUp($fixtures);
    $page = array_pop(LoadPageData::$pages);

    $route =  $this-&amp;gt;getUrl(&amp;#39;api_1_get_page&amp;#39;, array(&amp;#39;id&amp;#39; =&amp;gt; $page-&amp;gt;getId(), &amp;#39;_format&amp;#39; =&amp;gt; &amp;#39;json&amp;#39;));
    $this-&amp;gt;client-&amp;gt;request(&amp;#39;GET&amp;#39;, $route);
    $response = $this-&amp;gt;client-&amp;gt;getResponse();
    $this-&amp;gt;assertJsonResponse($response, 200);
    $content = $response-&amp;gt;getContent();

    $decoded = json_decode($content, true);
    $this-&amp;gt;assertTrue(isset($decoded[&amp;#39;id&amp;#39;]));
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The assertJsonResponse function is well described here: &lt;a href='http://williamdurand.fr/2012/08/02/rest-apis-with-symfony2-the-right-way/#testing'&gt;williamdurand-rest-apis-with-symfony2-the-right-way/#testing&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;the full test is visible here: /src/Acme/BlogBundle/Tests/Controller/PageControllerTest.php&lt;/p&gt;

&lt;p&gt;We have now to modify the function &lt;code&gt;getPage($id)&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// /src/Acme/BlogBundle/Controller/PageController.php

/**
 * Get single Page,
 *
 * @ApiDoc(
 *   resource = true,
 *   description = &amp;quot;Gets a Page for a given id&amp;quot;,
 *   output = &amp;quot;Acme\BlogBundle\Entity\Page&amp;quot;,
 *   statusCodes = {
 *     200 = &amp;quot;Returned when successful&amp;quot;,
 *     404 = &amp;quot;Returned when the page is not found&amp;quot;
 *   }
 * )
 *
 * @Annotations\View(templateVar=&amp;quot;page&amp;quot;)
 *
 * @param Request $request the request object
 * @param int     $id      the page id
 *
 * @return array
 *
 * @throws NotFoundHttpException when page not exist
 */
public function getPageAction($id)
{
    $page = $this-&amp;gt;container
        -&amp;gt;get(&amp;#39;acme_blog.blog_post.handler&amp;#39;)
        -&amp;gt;get($id);

    return $page;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;executing the test:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bin/phpunit -c app&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Woow green test!&lt;/p&gt;

&lt;p&gt;The bundle looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;src/Acme/BlogBundle/
    ├── AcmeBlogBundle.php
    ├── Controller
    │   └── PageController.php
    ├── DependencyInjection
    ├── Entity
    │   └── Page.php
    ├── Form
    │   └── PageType.php
    ├── Handler
    │   ├── PageHandlerInterface.php
    │   └── PageHandler.php
    ├── Model
    │   └── PageInterface.php
    ├── Resources
    └── Tests
        ├── Controller
        │   └── PageControllerTest.php
        ├── Fixtures
        │   └── Entity
        │       └── LoadPageData.php
        └── Handler
            └── PageHandlerTest.php&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='accessing_to_the_response'&gt;Accessing to the response&lt;/h2&gt;

&lt;p&gt;Is time to see how the application responses, so executing the php http server&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app/console server:run &amp;amp;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then accessing to the the resource with &lt;code&gt;wget&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget -S  localhost:8000/api/v1/pages/0.html&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will have a &lt;code&gt;500&lt;/code&gt; because the database is empty, and that resource doesn&amp;#8217;t exists:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--2013-11-09 15:46:37--  http://localhost:8000/api/v1/pages/0.html
Connecting to localhost (localhost)|127.0.0.1|:8000... connected.
HTTP request sent, awaiting response... 
  HTTP/1.0 500 Internal Server Error
  Content-type: text/html
2013-11-09 15:46:37 ERROR 500: Internal Server Error.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The resource &amp;#8216;0&amp;#8217; doesn&amp;#8217;t exists, but we want that the status codes reflects the application behaviour, so it should return a &lt;code&gt;404&lt;/code&gt; resource not found.&lt;/p&gt;

&lt;p&gt;We are going to create a private function that throws an Exception if the &lt;code&gt;Page&lt;/code&gt; is not found, the Exception will modify also automatically the Response Header.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Fetch the Page or throw a 404 exception.
 *
 * @param mixed $id
 *
 * @return PageInterface
 *
 * @throws NotFoundHttpException
 */
protected function getOr404($id)
{
    if (!($page = $this-&amp;gt;container-&amp;gt;get(&amp;#39;acme_blog.blog_post.handler&amp;#39;)-&amp;gt;get($id))) {
        throw new NotFoundHttpException(sprintf(&amp;#39;The resource \&amp;#39;%s\&amp;#39; was not found.&amp;#39;,$id));
    }

    return $page;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The controller now should use this function and executing &lt;code&gt;wget -S  localhost:8000/api/v1/pages/0.html&lt;/code&gt;, we receive a &lt;code&gt;404&lt;/code&gt; and we are happy :)&lt;/p&gt;

&lt;h2 id='content_negotiation'&gt;Content Negotiation&lt;/h2&gt;

&lt;p&gt;An important concept developing the REST API is the &lt;a href='http://en.wikipedia.org/wiki/Content_negotiation'&gt;Content Negotiation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you think that everything is a resource, maybe you care also about the name of the resource, if the page &lt;code&gt;10&lt;/code&gt; is at &lt;code&gt;/api/v1/pages/10&lt;/code&gt;, you may want to retrieve the same resource with different content type, not specifying the &lt;code&gt;format&lt;/code&gt; explicitly in the extension &lt;code&gt;/api/v1/pages/10.html&lt;/code&gt;, but instead using HTTP &lt;code&gt;Accept&lt;/code&gt; header.&lt;/p&gt;

&lt;p&gt;&lt;span&gt;EDIT&lt;/span&gt; removed the tags content-negotiation. If you want to play with the rest application without the extension, set false to &lt;code&gt;prefer_extension&lt;/code&gt; here:&lt;code&gt;https://github.com/liuggio/symfony2-rest-api-the-best-2013-way/blob/master/app/config/config.yml#L102&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Request: &lt;code&gt;curl -i localhost:8000/api/v1/pages/10&lt;/code&gt; No Accept header is sent so the fallback is &lt;code&gt;text/html&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK
Host: localhost:8000
Content-Type: text/html; charset=UTF-8
Allow: GET

&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;10- title&amp;lt;/h2&amp;gt;
&amp;lt;p&amp;gt;body&amp;lt;/p&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we retrieve the same resource changing the header:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -i -H &amp;quot;Accept: application/json&amp;quot;  localhost:8000/api/v1/pages/10&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tadaaaam the response is a json file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK
Host: localhost:8000
Content-Type: application/json
Allow: GET

{&amp;quot;id&amp;quot;:10,&amp;quot;title&amp;quot;:&amp;quot;title&amp;quot;,&amp;quot;body&amp;quot;:&amp;quot;body&amp;quot;}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We could also send different Content type accepted with different preferences eg:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -i -H &amp;quot;Accept: application/json; q=1.0, t/pages/10 q=0.8&amp;quot; localhost:8000/api/v1/&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The response will be a json file as well:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK
Host: localhost:8000
Content-Type: application/json
Allow: GET

{&amp;quot;id&amp;quot;:10,&amp;quot;title&amp;quot;:&amp;quot;title&amp;quot;,&amp;quot;body&amp;quot;:&amp;quot;body&amp;quot;}&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='recap'&gt;Recap&lt;/h2&gt;

&lt;p&gt;We have created a Doctrine entity called &lt;code&gt;Page&lt;/code&gt;, we have identified the methods of the interface that will be very useful later on. We first created a functional test, then the thin controller without logic. We have created unit test and then the service &lt;code&gt;PageHandler&lt;/code&gt; which instead of the controller, contains the logic to retrieve the information. We understood the importance of Content Negotiation.&lt;/p&gt;

&lt;h2 id='next__create_a_resource_with_api_rest'&gt;Next ›› &lt;a href='/web-api-rest-with-symfony2-the-best-way-the-post-method/'&gt;create a resource with API REST&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;In the next articles, we will describe how to use the page form as shared interface, we will create, modify, and delete Pages, with &lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;PATCH&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, and we will detail how use other important HTTP headers.&lt;/p&gt;

&lt;h3 id='references'&gt;References:&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href='http://www.symfony2.com'&gt;sf2 - Symfony.com&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.youtube.com/watch?v=Kkby5fG89K0'&gt;Lukas Kahwe Smith: resting with Sf2 - video&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://williamdurand.fr/2012/08/02/rest-apis-with-symfony2-the-right-way/'&gt;William Durand: rest-apis-with-symfony2-the-right-way - blog&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='https://speakerdeck.com/gordalina/rest-apis-made-easy-with-symfony2'&gt;Samuel Gordalina: REST APIs made easy with Symfony2 - slide&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.slideshare.net/dlondero/rest-in-practice-27335543'&gt;Daniel Londero: Rest in practice - slide&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content>
 </entry>
 
 <entry>
   <title>Symfony2 design patterns @ symfonyday</title>
   <link href="http://welcometothebundle.com/symfony2-design-patterns"/>
   <updated>2013-10-18T00:00:00+02:00</updated>
   <id>http://welcometothebundle.com/symfony2-design-patterns</id>
   <content type="html">&lt;p&gt;I had the good fortune of being able to speech for the second time in a row, on the Symfony-Day conference.&lt;/p&gt;

&lt;p&gt;This time I had a quality partner &lt;a href='http://giorgiocefaro.com/'&gt;mr @giorrrgio (Giorgio Cefaro)&lt;/a&gt;, we talked about design patterns in Symfony2, and even about some Anti-patterns.&lt;/p&gt;

&lt;p&gt;&lt;a href='http://www.slideshare.net/liuggio/design-pattern-symfony2'&gt;Design pattern symfony2 - Nanos gigantium humeris insidentes&lt;/a&gt;.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Design by contract behaviour</title>
   <link href="http://welcometothebundle.com/design-by-contract-behaviour"/>
   <updated>2013-09-11T00:00:00+02:00</updated>
   <id>http://welcometothebundle.com/design-by-contract-behaviour</id>
   <content type="html">&lt;p&gt;In recent years, &lt;a href='http://getcomposer.org'&gt;Composer&lt;/a&gt; has given a breath of freshness to the dependencies, and framework such as &lt;a href='http://www.symfony.com'&gt;Symfony2&lt;/a&gt; have made best practices and decoupling their pride.&lt;/p&gt;

&lt;p&gt;The union of these two phenomena have moved the attentions to the type hinting in order to have contracts with &lt;code&gt;Interfaces&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;PHP doesn&amp;#8217;t have the support for &lt;a href='http://en.wikipedia.org/wiki/Structural_type_system'&gt;Structural type system&lt;/a&gt;&lt;/p&gt;

&lt;h2 id='the_problem'&gt;The problem&lt;/h2&gt;

&lt;p&gt;The problem comes when a library uses a functionality of a third library, but do not want to hard-code the third-part library in the namespace&lt;/p&gt;

&lt;h2 id='case_study'&gt;Case Study&lt;/h2&gt;

&lt;p&gt;I have a library that uses a logger:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// src/Service/MyService
namespace MyLib\Service;

class MyService

   private $log;

   public function __construct($log)
   {
     this-&amp;gt;log = $log;
   }

   public function doSomethig()
   {
      $this-&amp;gt;log-&amp;gt;info(&amp;#39;log this&amp;#39;);
   }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I want to use the type hinting because that dependency will be called with &lt;code&gt;info&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Then I add the type-hinting LoggerInterface, but which namespace to use? I can&amp;#8217;t define a new mine LoggerInterface, so use the Monolog one.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// src/Service/MyService
namespace MyLib\Service;

use Monolog\LoggerInterface;

class MyService

   private $log;

   public function __construct(LoggerInterface $log)
   {
     this-&amp;gt;log = $log;
   }

   public function doSomethig()
   {
      $this-&amp;gt;log-&amp;gt;info(&amp;#39;log this&amp;#39;);
   }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Doing this I have hardcoded a &lt;strong&gt;dependency&lt;/strong&gt; to the Monolog library, composer.json and this file &lt;code&gt;src/Service/MyService&lt;/code&gt; has to be maintained together, isn&amp;#8217;t smell to you?&lt;/p&gt;

&lt;p&gt;And what happen when I&amp;#8217;ll find a better logger library that has got the same LoggerInterface and the function &amp;#8216;info&amp;#8217;? I&amp;#8217;ve to change the namespace to the new LoggerInterface or the type hinting would fail, because the control for the type hinting is also on the namespace of the interface and not on the behaviour.&lt;/p&gt;

&lt;h2 id='solution'&gt;Solution?&lt;/h2&gt;

&lt;p&gt;Monolog have fixed this problem by putting a shared interface inside PSR &lt;a href='http://www.php-fig.org'&gt;php-fig.org/&lt;/a&gt; repository, but not all cases can be put in the php-fig.&lt;/p&gt;

&lt;p&gt;One solution would be to permit the alias for namespaces.&lt;/p&gt;

&lt;p&gt;Another &lt;code&gt;naive&lt;/code&gt; solution would be modify the &lt;code&gt;php-internal&lt;/code&gt; of how type hinting works, maybe defining an interface with a sort of keyword eg.&lt;code&gt;behaviour&lt;/code&gt; that forces the engine to check that the type that you pass has the same behavior (functions) and not forcing the namespace.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;namespace MyLib;
Behaviour Interface LoggerInterface
{
    public function info($string);
}&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='why'&gt;Why?&lt;/h2&gt;

&lt;p&gt;Can you imagine a world where the libraries are decoupled but they respects the interfaces without sharing file but sharing &lt;code&gt;behaviour&lt;/code&gt;?&lt;/p&gt;

&lt;h2 id='phpfig'&gt;PHP-fig&lt;/h2&gt;

&lt;p&gt;PHP-fig is a great tool but it&amp;#8217;s democratic and democracy on internet is not always able to satisfy the minorities, and to be competitive with the times.&lt;/p&gt;

&lt;h2 id='another_example'&gt;Another example&lt;/h2&gt;

&lt;p&gt;Another example, if you want to use this library http://yohan.giarel.li/Finite/index.html, you have to put a dependency with Finite\StatefulInterface only because your class has to have the functions &lt;code&gt;getFiniteState&lt;/code&gt; and &lt;code&gt;setFiniteState&lt;/code&gt;, this is good and it works but hard-coding namespaces and dependencies is not the best option.&lt;/p&gt;

&lt;h2 id='what_do_you_think_about_it'&gt;What do you think about it?&lt;/h2&gt;

&lt;h2 id='edit'&gt;EDIT&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;That&amp;#8217;s a RFC for that&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Giorgio told me about this RFC: &lt;a href='https://wiki.php.net/rfc/protocol_type_hinting'&gt;php.net/rfc/protocol_type_hinting&lt;/a&gt;.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Caching and data analysis will move your application to the next level</title>
   <link href="http://welcometothebundle.com/caching-and-data-analysis-will-move-your-application-to-the-next-level"/>
   <updated>2013-05-17T00:00:00+02:00</updated>
   <id>http://welcometothebundle.com/caching-and-data-analysis-will-move-your-application-to-the-next-level</id>
   <content type="html">&lt;h3 id='if_you_dont_ignore_data_you_could_find_a_business_value'&gt;If you don&amp;#8217;t ignore data you could find a business value.&lt;/h3&gt;

&lt;p&gt;The presentation focuses on data analysis, how to track and measure applications and why the use of software metrics that push information are essential.&lt;/p&gt;

&lt;p&gt;Delegates will be shown practical examples of how Terravision uses Statsd, Sentry versus Graylog for the error behavior analysis of users, applications, operating systems and web servers.&lt;/p&gt;

&lt;p&gt;The final part of the presentation concludes with methodologies of advanced scalability, events, messages and queues.&lt;/p&gt;

&lt;p&gt;&lt;a href='http://www.slideshare.net/liuggio/caching-and-data-analysis-will-move-your-symfony2-application-to-the-next-level'&gt;Caching and data analysis will move your Symfony2 application to the next level&lt;/a&gt;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Doctrine2 tracking policy</title>
   <link href="http://welcometothebundle.com/doctrine2-tracking-policy"/>
   <updated>2013-04-23T00:00:00+02:00</updated>
   <id>http://welcometothebundle.com/doctrine2-tracking-policy</id>
   <content type="html">&lt;h1 id='which_tracking_policy_are_you_using'&gt;Which tracking policy are you using?&lt;/h1&gt;

&lt;p&gt;With doctrine you can change the tracking policy for each entity, the tracking policy is the way in which Doctrine understands if a entity property must be &amp;#8216;saved&amp;#8217; in the database.&lt;/p&gt;

&lt;p&gt;Doctrine definition: &amp;#8220;Change tracking is the process of determining what has changed in managed entities since the last time they were synchronized with the database.&amp;#8221;&lt;/p&gt;

&lt;p&gt;There are 3 tracking policies: Implicit, Explicit, Nofity.&lt;/p&gt;

&lt;h2 id='implicit_tracking_the_default_one'&gt;Implicit tracking (the default one)&lt;/h2&gt;

&lt;p&gt;The implicit is the default one and the slowest, you don&amp;#8217;t need to explicit call &amp;#8216;persist&amp;#8217; eg.&lt;/p&gt;

&lt;p&gt;&lt;code&gt; // $entity is not a new object, and has $entity-&amp;gt;Title = &amp;#39;liuggio loves tvision.github.io&amp;#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt; $entity-&amp;gt;setTitle(&amp;#39;liuggio loves symfony2&amp;#39;);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt; $entityManager-&amp;gt;flush();&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt; echo $entity-&amp;gt;getTitle();   // output &amp;#39;liuggio loves symfony2&amp;#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Unit of work now has &lt;strong&gt;$entity.title=liuggio loves symfony2&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Database has flushed without persist &lt;strong&gt;$entity.title=liuggio loves symfony2&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pro&lt;/strong&gt;: &lt;code&gt;$entityManager-&amp;gt;persist($entity)&lt;/code&gt; is not necessary&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cons&lt;/strong&gt;: Slowness, Doctrine has to check property-by-property for all the object in the unit of work&lt;/p&gt;

&lt;h2 id='the_explicit_tracking_the_suggested_one'&gt;The explicit tracking (the suggested one)&lt;/h2&gt;

&lt;p&gt;You have to explicit flag which object you want to persist, than Doctrine will check property-by-property in order to find with property has changed.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pro&lt;/strong&gt;: Faster than implicit, must if you have a lot of entities.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cons&lt;/strong&gt;: the object in the unit of work could be different from that one in the db, not easy to debug.&lt;/p&gt;

&lt;p&gt;The example&lt;/p&gt;

&lt;p&gt;&lt;code&gt; // $entity is not a new object, and has $entity-&amp;gt;Title = &amp;#39;liuggio loves tvision.github.io&amp;#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt; $entity-&amp;gt;setTitle(&amp;#39;liuggio loves symfony2&amp;#39;);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt; $entityManager-&amp;gt;flush();&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt; echo $entity-&amp;gt;getTitle();   // output &amp;#39;liuggio loves symfony2&amp;#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Unit of work now has &lt;strong&gt;$entity.title=liuggio loves symfony2&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Database has different state for that entity &lt;strong&gt;liuggio loves tvision.github.io&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id='notify_tracking'&gt;Notify tracking&lt;/h2&gt;

&lt;p&gt;It&amp;#8217;s not really a tracking policy, if you want to develop your own tracking policy, you have the tool for doing it.&lt;/p&gt;

&lt;p&gt;Don&amp;#8217;t understimate this policy useful if you a domain logic.&lt;/p&gt;

&lt;h2 id='link_to_doctrine_doc'&gt;Link to doctrine doc&lt;/h2&gt;

&lt;p&gt;&lt;a href='http://docs.doctrine-project.org/en/latest/reference/change-tracking-policies.html'&gt;doctrine/change-tracking-policies&lt;/a&gt;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>It is all about behaviour also in php</title>
   <link href="http://welcometothebundle.com/it-is-all-about-behaviour-also-in-php"/>
   <updated>2013-03-10T00:00:00+01:00</updated>
   <id>http://welcometothebundle.com/it-is-all-about-behaviour-also-in-php</id>
   <content type="html">&lt;p&gt;It is a shame I never had energy to continue the BDD saga started with: &lt;a href='http://welcometothebundle.com/phpunit-vs-phpspec-theory-on-behaviour-driven-development'&gt;phpunit-vs-phpspec-theory-on-behaviour-driven-development 1/3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;During our monthly meeting at &lt;a href='http://roma.grusp.org/2013/03/incontro-di-febbraio-2013/'&gt;Pug Roma&lt;/a&gt;, I have talked about php-spec and behaviour driven development.&lt;/p&gt;

&lt;p&gt;&lt;a href='http://www.slideshare.net/liuggio/its-all-about-behaviour-also-in-php'&gt;phpspec/It is all about behaviour also in php&lt;/a&gt;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>The meaning of Cache for a web developer no more too many connection</title>
   <link href="http://welcometothebundle.com/the-meaning-of-cache-for-a-web-developer-no-more-too-many-connection"/>
   <updated>2013-02-22T00:00:00+01:00</updated>
   <id>http://welcometothebundle.com/the-meaning-of-cache-for-a-web-developer-no-more-too-many-connection</id>
   <content type="html">&lt;p&gt;In the place of Mr. Obvious I&amp;#8217;m going to describe what really cache means, there is a lot of confusion between what the cache &lt;strong&gt;is&lt;/strong&gt;, what it &lt;strong&gt;does&lt;/strong&gt; and all the possible &lt;strong&gt;uses&lt;/strong&gt; and &lt;strong&gt;implementations&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;All the fuss comes from the use&lt;strong&gt;s&lt;/strong&gt; of that polysemous word.&lt;/p&gt;

&lt;h2 id='definition'&gt;Definition:&lt;/h2&gt;

&lt;p&gt;We should start from &lt;strong&gt;Wikipedia&lt;/strong&gt;, “Cache is a component that transparently stores data so that future requests for that data can be served faster.”&lt;/p&gt;

&lt;p&gt;So instead of doing a time consuming calculation if you already &amp;#8216;remember&amp;#8217; the result answer it.&lt;/p&gt;

&lt;p&gt;The concept seems simple, the problem is it could be used in a myriad of ways.&lt;/p&gt;

&lt;p&gt;Important words:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A &lt;strong&gt;Cache Hit&lt;/strong&gt; happens if the Cache contains the answer.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;A &lt;strong&gt;Cache Miss&lt;/strong&gt; happens if the Cache doesn’t contain the answer.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id='some_standard_code'&gt;Some &amp;#8216;standard&amp;#8217; Code:&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Doctrine&lt;/strong&gt; defines the cache interface with &lt;a href='https://github.com/doctrine/cache/blob/master/lib/Doctrine/Common/Cache/Cache.php'&gt;Doctrine/Common/Cache/Cache.php&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function fetch($id);
function contains($id);
function save($id, $data, $lifeTime = 0);
function delete($id);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;PHP fig-standards&lt;/strong&gt; proposed the cache with &lt;a href='https://github.com/php-fig/fig-standards/issues?labels=Cache&amp;amp;page=1&amp;amp;state=open'&gt;proposed/PSR-Cache.md&lt;/a&gt;&lt;/p&gt;

&lt;h2 id='implementations'&gt;Implementations:&lt;/h2&gt;

&lt;p&gt;As web developers the cache is an essential tool, we have to divide the cache features from its implementations.&lt;/p&gt;

&lt;h3 id='1_http_cache'&gt;1. HTTP Cache&lt;/h3&gt;

&lt;h4 id='description'&gt;Description&lt;/h4&gt;

&lt;p&gt;OK - describing the HTTP Cache is a huge task, and heaps of great developers already did this (&lt;a href='https://www.google.com/search?q=http+cache'&gt;google&lt;/a&gt;, &lt;a href='http://www.slideshare.net/fabpot/caching-on-the-edge'&gt;fabpot/caching-on-the-edge&lt;/a&gt;), the concept in few lines is that you are a web developer, and the web works with the HTTP Protocol, so you HAVE to study the HTTP Protocol.&lt;/p&gt;

&lt;p&gt;I won&amp;#8217;t go in depth with HTTP Protocol and Cache, but understanding the HTTP protocol turns a developer in a web developer.&lt;/p&gt;

&lt;p&gt;The actors in the HTTP Cache are: your web-server, your reverse proxy (as Varnish or Squid), the Shared cache server&lt;strong&gt;s&lt;/strong&gt; (more than one) and the client browser cache.&lt;/p&gt;

&lt;p&gt;This is the best Cache and the most powerful, you could create many cache layers on your application, but if you set up the HTTP headers properly the first time, the next requests will be served for free. &lt;strong&gt;The least expensive query is the query you never had&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id='enemies'&gt;Enemies&lt;/h4&gt;

&lt;p&gt;An enemy of your mental health is the &lt;strong&gt;invalidation&lt;/strong&gt;, do not waste time trying to find a solutions for invalidating cache, choose only the best validation.&lt;/p&gt;

&lt;p&gt;The HTTP cache enemy? Cookies and Sessions (see how to solve it thanks to &lt;a href='https://www.google.it/search?client=ubuntu&amp;amp;channel=fs&amp;amp;q=ESI+cache&amp;amp;ie=utf-8&amp;amp;oe=utf-8&amp;amp;redir_esc=&amp;amp;ei=P6QnUbS5AsbKtAbdQQ'&gt;ESI&lt;/a&gt;)&lt;/p&gt;

&lt;h4 id='best_tools'&gt;Best Tools&lt;/h4&gt;

&lt;p&gt;Varnish / Squid&lt;/p&gt;

&lt;h3 id='2_opcode'&gt;2. Opcode&lt;/h3&gt;

&lt;h4 id='description'&gt;Description&lt;/h4&gt;

&lt;p&gt;“APC is a performance-enhancing extension. It should not be confused with a magic pill, although having it around does provide a positive impact on performance! If configured incorrectly, APC can cause unexpected behaviour, however when implemented optimally APC can be a useful weapon in your arsenal.” &lt;a href='http://techportal.inviqa.com/2010/10/07/understanding-apc/'&gt;read more on understanding APC&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This should be a must for you my dear PHP developer.&lt;/p&gt;

&lt;h4 id='best_tools'&gt;Best Tools&lt;/h4&gt;

&lt;p&gt;APC o Zend Optimizer+.&lt;/p&gt;

&lt;h3 id='3_the_cache_of_your_application__framework'&gt;3. The Cache of your application / framework&lt;/h3&gt;

&lt;h4 id='description'&gt;Description&lt;/h4&gt;

&lt;p&gt;The framework is a tool that should helps you sort and easily create the logic of your domain, to do this it provides files and configurators, which are usually elaborated in PHP files, the cache is used to not process at each request.&lt;/p&gt;

&lt;p&gt;For example with Symfony2 in the application cache folders you will find, Url creator files, Proxy Classes, Configuration files (ini, yml, xml) converted to PHP files, Annotations etc&amp;#8230;&lt;/p&gt;

&lt;h4 id='best_tools'&gt;Best Tools&lt;/h4&gt;

&lt;p&gt;Configuration file to PHP then any Opcode.&lt;/p&gt;

&lt;h3 id='4_template_and_file_system_caching'&gt;4. Template and File System Caching&lt;/h3&gt;

&lt;h4 id='description'&gt;Description&lt;/h4&gt;

&lt;p&gt;Good Template engines, Smarty and Twig provide a caching system using precompiled pieces of code already in a file into the file system.&lt;/p&gt;

&lt;h4 id='best_tools'&gt;Best Tools&lt;/h4&gt;

&lt;p&gt;There is no better cache then the Opcode for serving this type of file.&lt;/p&gt;

&lt;p&gt;Recently a Pull Request has also been refused, it allows Twig to use any other type of cache &lt;a href='https://github.com/fabpot/Twig/issues/728'&gt;issue on github&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id='5_query_results'&gt;5. Query Results&lt;/h3&gt;

&lt;h4 id='description'&gt;Description&lt;/h4&gt;

&lt;p&gt;You are Object Oriented programmers, do not waste your time normalizing the database, if you have too many JOIN delegated the speed to the cache layer.&lt;/p&gt;

&lt;p&gt;Queries can be large objects, better to put a centralized server, The enemy is the period of validity vs. freshness, and the size of the query.&lt;/p&gt;

&lt;h4 id='best_tools'&gt;Best Tools&lt;/h4&gt;

&lt;p&gt;Redis/Memcache(d), but &lt;a href='http://www.slideshare.net/uptimeforce/postgresql-query-cache-pqc'&gt;PostgreSQL-cache&lt;/a&gt; has a great internal cache layer, also MySQL has it.&lt;/p&gt;

&lt;h3 id='6_query_caching'&gt;6. Query Caching&lt;/h3&gt;

&lt;h4 id='description'&gt;Description&lt;/h4&gt;

&lt;p&gt;Some ORM as Doctrine stores the query creation in order to not process it twice.&lt;/p&gt;

&lt;h4 id='best_tools'&gt;Best Tools&lt;/h4&gt;

&lt;p&gt;APC or Redis/Memcache(d)&lt;/p&gt;

&lt;h2 id='simple_rules'&gt;Simple Rules&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;If you want to not process content of ini files or xml files or yml files, you could convert to PHP or you could store data see &lt;strong&gt;3.&lt;/strong&gt;&lt;/li&gt;

&lt;li&gt;If you want to cache PHP files use Opcode caching.&lt;/li&gt;

&lt;li&gt;If you want to store variable contents or Objects use Redis, Memcache(d), or you could also use APC &lt;a href='http://php.net/manual/en/function.apc-store.php'&gt;apc-store&lt;/a&gt; (suggested if you have a single web server)&lt;/li&gt;

&lt;li&gt;If you have provide some content use HTTP Cache always and in order to serve assets (file css, js, static content) use some famous CDN or Nginx or some free/cheap cdn service on the net.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id='other_cache_mechanisms'&gt;Other Cache mechanisms&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Pre-Caching/Cacheback, sometimes you need to have some data already available and you don&amp;#8217;t want that the first request wait some slow task &lt;a href='http://codeinthehole.com/writing/cacheback-asynchronous-cache-refreshing-for-django'&gt;cacheback-asynchronous-cache-refreshing-for-django&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://www.howtoforge.com/why-you-should-always-use-nginx-with-microcaching'&gt;Microcaching&lt;/a&gt;, few seconds of cache, useful for GET or &lt;strong&gt;POST&lt;/strong&gt;. I said &lt;strong&gt;POST&lt;/strong&gt;, do not it seemed strange to you? If you jumped on the chair is ok, POST on cache is insane, unless you do not want to avoid double click.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;Before there were static website in HTML, then dynamic languages ​​and databases, and we finally came to the static pages again, this blog has been developed with &lt;a href='http://jekyllbootstrap.com/lessons/jekyll-introduction.html'&gt;jekyll&lt;/a&gt;,&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content>
 </entry>
 
 <entry>
   <title>PHPUnit vs PHPSpec: theory on Behaviour Driven Development 1/3</title>
   <link href="http://welcometothebundle.com/phpunit-vs-phpspec-theory-on-behaviour-driven-development"/>
   <updated>2013-01-05T00:00:00+01:00</updated>
   <id>http://welcometothebundle.com/phpunit-vs-phpspec-theory-on-behaviour-driven-development</id>
   <content type="html">&lt;p&gt;The first part of a series of short articles (maybe three) where I&amp;#8217;d like to share my tiny experience with BDD and in particular with PHPSpec.&lt;/p&gt;

&lt;h2 id='phpunit_vs_phpspec_a_word_on_behaviour_testing'&gt;PHPUnit vs &lt;a href='https://github.com/phpspec/phpspec2'&gt;PHPSpec&lt;/a&gt;: A word on behaviour testing&lt;/h2&gt;

&lt;p&gt;I recently discovered that there is an alternative to PHPUnit, and I really like this new approach.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt; But why an alternative if PHPUnit does everything I need?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt; What could be changed is the way of doing test,&lt;/p&gt;

&lt;p&gt;If you&amp;#8217;ve ever worked in TDD, you know it&amp;#8217;s very time consuming&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;create - create or modify the test&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;fail - see it fail&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;pass - code the minimum to get the test passed&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;refactor - Refactoring&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;go to step 1&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id='the_differences_in_a_sentence'&gt;The differences in a sentence&lt;/h2&gt;

&lt;p&gt;If the story is a key of the development, the behaviour is the differrence between TDD and BDD.&lt;/p&gt;

&lt;p&gt;If you need to test the insertion of an object into a collection and the collection is represented by an Array, with xUnit you should assert that the collection contains the object in the Array, but if the collection will change to another type of container, graph for example, the xUnit will fail, even if the behaviour is unchanged. In BDD you are not testing you are describing what that classes will do, and so you can continue creating the class (PHPSpec will create the class and the methods for you)&lt;/p&gt;

&lt;h2 id='bdd'&gt;BDD&lt;/h2&gt;

&lt;p&gt;There are several BDD frameworks on PHP depending on what you want to test.&lt;/p&gt;

&lt;h4 id='external_behaviour'&gt;External behaviour&lt;/h4&gt;

&lt;p&gt;&lt;a href='http://behat.org/'&gt;Behat&lt;/a&gt; deals to have specifications that reflects the environment from the outside.&lt;/p&gt;

&lt;h4 id='internal_behaviour'&gt;Internal behaviour&lt;/h4&gt;

&lt;p&gt;&lt;a href='https://github.com/phpspec/phpspec2'&gt;PHPSpec&lt;/a&gt; responds to the behaviour in the lower level, from the internal of the classes.&lt;/p&gt;

&lt;p&gt;&lt;a href='https://github.com/phpspec/phpspec2'&gt;PHPSpec&lt;/a&gt; is considered a tool that helps you to develop.&lt;/p&gt;

&lt;h2 id='summary'&gt;Summary&lt;/h2&gt;

&lt;p&gt;The BDD tests what the object does instead of what it is, and what it does is much more important.&lt;/p&gt;

&lt;p&gt;We have to say that Ruby community helped a lot the evolution of BDD, RSpec is a standard-de-facto, in Ruby world.&lt;/p&gt;

&lt;h2 id='faq'&gt;FAQ&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt; When I should use PHPUnit and when to use &lt;a href='https://github.com/phpspec/phpspec2'&gt;PHPSpec&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt; There isn&amp;#8217;t a better way between the two, depending on how you want to approach the problem, if you want to follow the behaviour or a unit test the code.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt; With PHPUnit I could do the same things as I could do with &lt;a href='https://github.com/phpspec/phpspec2'&gt;PHPSpec&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt; Absolutely, in fact there is a mapping between the two&lt;/p&gt;

&lt;p&gt;• Assertion Becomes expectation.&lt;/p&gt;

&lt;p&gt;• Test method Becomes code example&lt;/p&gt;

&lt;p&gt;• Test case example Becomes group&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BUT&lt;/strong&gt; You would be distracted by the code loosing focus on the result, and you might miss the concept of behaviour. [EDITED 07-01-2013 thanks to &lt;a href='http://twitter.com/euxpom'&gt;euxpom &lt;img src='http://gravatar.com/avatar/77014411a56fa9c746d6a89b7fd96121?size=20' alt='exupom' /&gt;&lt;/a&gt;]&lt;/p&gt;

&lt;h2 id='phpspec_advantages'&gt;&lt;a href='https://github.com/phpspec/phpspec2'&gt;PHPSpec&lt;/a&gt; advantages&lt;/h2&gt;

&lt;p&gt;xSpec is context specific, expectation, the output is the documentation and it is for this reason that the language is used because the same syntax you guide you to focus in behaviour, and the importance of documentation.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bin/phpspec run -f prettify -v&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So the big change is on how you write test code.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;In the next post I will show some examples on how you could use &lt;a href='https://github.com/phpspec/phpspec2'&gt;PHPSpec&lt;/a&gt; to test some (in)famous design pattern.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id='bibliography'&gt;Bibliography&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href='http://pragprog.com/book/achbd/the-rspec-book'&gt;The RSpec Book Behaviour-Driven Development with RSpec, Cucumber, and Friends&lt;/a&gt; by David Chelimsky, Dave Astels, Zach Dennis, Aslak Hellesøy, Bryan Helmkamp, Dan North&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;Test Driven Development. By Example di Kent Beck (dic. 2002)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</content>
 </entry>
 
 <entry>
   <title>Automate Test and Code Inspection in PHP with Guard, and Symfony2</title>
   <link href="http://welcometothebundle.com/automate-test-and-code-inspection-in-php-with-guard-and-symfony2"/>
   <updated>2013-01-03T00:00:00+01:00</updated>
   <id>http://welcometothebundle.com/automate-test-and-code-inspection-in-php-with-guard-and-symfony2</id>
   <content type="html">&lt;h2 id='hey_phper_do_you_automate_your_test'&gt;Hey PHPer do you automate your test?&lt;/h2&gt;

&lt;p&gt;In everyday life there are tools that can not only speed, but also lighten the workload of your mind, in that regard I wanted to share a useful library: &lt;a href='https://github.com/guard/guard'&gt;Guard&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id='_guard'&gt;&lt;code&gt;Watch&lt;/code&gt; Guard!&lt;/h2&gt;

&lt;p&gt;&lt;a href='https://github.com/guard/guard'&gt;Guard&lt;/a&gt; is written in Ruby, it automates commands based on events that happen in the filesystem.&lt;/p&gt;

&lt;p&gt;&lt;a href='https://github.com/guard/guard'&gt;Guard&lt;/a&gt; in a short time has become popular especially in the automate testing.&lt;/p&gt;

&lt;p&gt;You can easily edit your files, having only the front window of your editor/IDE, each change will run the test, and you will be notified.&lt;/p&gt;

&lt;p&gt;Indeed during these years of development, especially in PHP I overstimulated shortcuts, I have become a slave of the keyboard, &lt;strong&gt;Alt-Tab&lt;/strong&gt;, &lt;strong&gt;Key-Up + Enter&lt;/strong&gt; for example, are a must for TDD programmers .&lt;/p&gt;

&lt;p&gt;For years I had the &lt;strong&gt;CTRL+S&lt;/strong&gt; tic, in fact in my life I have saved (by mistake) around 2000 pages browsing with Firefox.&lt;/p&gt;

&lt;p&gt;Before finding out &lt;a href='https://github.com/guard/guard'&gt;Guard&lt;/a&gt;, I was using a crude one-line script, it runs each 3 seconds PHPUnit if error otherwise waits 10 seconds&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while true; do clear; phpunit; if [ ! $? ]; then sleep 10; else sleep 3;fi; done;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but it was not enough, I needed something which could perform only the Test for the file that I had changed: &lt;a href='https://github.com/Maher4Ever/guard-phpunit'&gt;guard-phpunit&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In the PHP world, &lt;a href='https://github.com/guard/guard'&gt;Guard&lt;/a&gt; is not so popular but instead would require much more importance.&lt;/p&gt;

&lt;h2 id='install_guardphpunit'&gt;&lt;strong&gt;Install&lt;/strong&gt; &lt;a href='https://github.com/Maher4Ever/guard-phpunit'&gt;guard-phpunit&lt;/a&gt;!&lt;/h2&gt;

&lt;p&gt;Simply follow the instructions of the README.md https://github.com/Maher4Ever/guard-phpunit&lt;/p&gt;

&lt;h3 id='1_install_guardphpunit'&gt;1 Install guard-phpunit&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;gem install guard-phpunit&lt;/code&gt;&lt;/p&gt;

&lt;h3 id='2_step_create_a_'&gt;2 Step create a &lt;code&gt;Guardfile&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;guard &amp;#39;phpunit&amp;#39;, :tests_path =&amp;gt; &amp;#39;Tests&amp;#39;, :cli =&amp;gt; &amp;#39;--colors&amp;#39; do
 # Watch tests files
 watch(%r{^.+Test\.php$})
 # Watch library files and run their tests
 watch(%r{^Object/(.+)\.php}) { |m| &amp;quot;Tests/#{m[1]}Test.php&amp;quot; }
end&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='3_run_with_'&gt;3 Run with &lt;code&gt;guard&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;liuggio@liuggio:/var/repos/StatsDClientBundle$ guard
20:33:21 - INFO - Guard uses NotifySend to send notifications.
20:33:21 - INFO - Guard uses TerminalTitle to send notifications.
20:33:21 - INFO - Running all tests
20:33:23 - INFO - ..................
&amp;gt; [#51616B16C20E]
&amp;gt; [#51616B16C20E] Finished in 2 seconds
&amp;gt; [#51616B16C20E] 18 tests, 43 assertions
20:33:23 - INFO - Guard is now watching at &amp;#39;/var/www/StatsDClientBundle&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will test the entire library for you, any changes will test only the files that have changed&lt;/p&gt;

&lt;p&gt;If you install &lt;code&gt;libnotify&lt;/code&gt; with&lt;/p&gt;

&lt;p&gt;&lt;code&gt;gem install libnotify&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;you will have an Icon next your top panel&lt;/p&gt;

&lt;p&gt;&lt;img src='http://welcometothebundle.com/assets/themes/readable-liuggio/img/guard-phpunit-sf2.png' alt='liuggio-guard-phpunit-sf2-notifier' /&gt;&lt;/p&gt;

&lt;h3 id='4_trick_guard_on_large_directories'&gt;4 Trick Guard on large directories&lt;/h3&gt;

&lt;p&gt;If you have big project you need to increase the amount of watches of libnotify&lt;/p&gt;

&lt;p&gt;see this page for more info: https://github.com/guard/listen/wiki/Increasing-the-amount-of-inotify-watchers&lt;/p&gt;

&lt;h2 id='_guard'&gt;&lt;code&gt;Inspect&lt;/code&gt; Guard!&lt;/h2&gt;

&lt;p&gt;Another plugin that I suggest is Guard for code inspection:&lt;/p&gt;

&lt;p&gt;is easy to install&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo pear install PHP_CodeSniffer
sudo gem install guard-phpcs&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then add to your Guardfile&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;guard &amp;#39;phpunit&amp;#39;, :tests_path =&amp;gt; &amp;#39;Tests&amp;#39;, :cli =&amp;gt; &amp;#39;--colors&amp;#39; do
 # Watch tests files
 watch(%r{^.+Test\.php$})
 # Watch library files and run their tests
 watch(%r{^/(.+)/(.+)/(.+)\.php}) { |m| &amp;quot;Test/#{m[1]}/#{m[2]}/#{m[3]}Test.php&amp;quot; }
end
guard &amp;#39;phpcs&amp;#39;, :standard =&amp;gt; &amp;#39;PSR1&amp;#39; do
    watch(%r{.*\.php$})
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will detect all the camel case problems, and you will have to follow the standard PSR1 :D&lt;/p&gt;

&lt;h2 id='guard____guardphpunitsf2'&gt;Guard + &lt;code&gt;Symfony2&lt;/code&gt; = &lt;a href='https://github.com/liuggio/guard-phpunit-sf2'&gt;guard-phpunit-sf2&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Unfortunately &lt;code&gt;guard-phpunit&lt;/code&gt; does not work with symfony2 framework,&lt;/p&gt;

&lt;p&gt;so I forked that repo and I made &lt;a href='https://github.com/liuggio/guard-phpunit-sf2'&gt;guard-phpunit-sf2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hurray!!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;guard-phpunit-sf2 has not been pushed on RubyGems. If you want to try it, clone the repository, build the gem and install it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone git@github.com:liuggio/guard-phpunit-sf2.git
cd guard-phpunit-sf2
gem build guard-phpunit-sf2.gemspec
sudo gem instal guard-phpunit-sf2-0.1.4.gem&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then create the Guardfile into the root of your Symfony2 project&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;guard &amp;#39;phpunit&amp;#39;, :cli =&amp;gt; &amp;#39;--colors -c app/&amp;#39; do
     # Watch tests files
     watch(%r{^src\/.+Test\.php$})

     # Watch src file and run its test,
     # Test string: src/Tvision/Bundle/CartBundle/Repository/CartRepository.php
     watch(%r{^src\/(.+)\/(.+)Bundle\/(.+)\.php$}) { |m| &amp;quot;src/#{m[1]}/#{m[2]}Bundle/Tests/#{m[3]}Test.php&amp;quot; } # Watch all files in your bundles and run the respective tests on change
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then lunch &lt;code&gt;guard&lt;/code&gt; and start testing.&lt;/p&gt;

&lt;p&gt;PS: maybe you should uninstall guard-phpunit in order to work with symfony2 :|&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo gem uninstall guard-phpunit&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Happy test to everybody.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>ServerGrove StastdClientBundle Interesting Symfony Bundles</title>
   <link href="http://welcometothebundle.com/servergrove-stastdclientbundle-interesting-symfony-bundles"/>
   <updated>2012-11-01T06:01:25+01:00</updated>
   <id>http://welcometothebundle.com/servergrove-stastdclientbundle-interesting-symfony-bundles</id>
   <content type="html">&lt;p&gt;I was contacted by &lt;a href='https://twitter.com/_leopro_'&gt;leopro&lt;/a&gt; &lt;img src='https://en.gravatar.com/avatar/26d90e88b1eb694cc1276b9ab8d7630f?s=30' alt='leopro' /&gt; who congratulated me for the excellent results obtained with the &lt;a href='https://github.com/liuggio/StatsDClientBundle'&gt;StatsDClientBundle&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Thanks to this comment I now know that &lt;a href='http://blog.servergrove.com/2012/10/09/interesting-symfony-bundles-statsdclientbundle/'&gt;ServerGrove&lt;/a&gt; chosen &lt;a href='https://github.com/liuggio/StatsDClientBundle'&gt;StatsD Client Bundle&lt;/a&gt; as its top choice for Symfony2 project among more than 1600.&lt;/p&gt;

&lt;p&gt;cite&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;There are well over 1600 public bundles at knpbundles.com, so sometimes really interesting and good bundles are hard time find. So we will revive the old series but this time we will do it with bundles.
In our first installment of the series we will present StatsDClientBundle written by Giulio De Donato. `&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Anyone who follows a conference in europe about web developing or PHP knows &lt;a href='http://blog.servergrove.com/2012/10/09/interesting-symfony-bundles-statsdclientbundle/'&gt;ServerGrove&lt;/a&gt;, I thank them.&lt;/p&gt;

&lt;p&gt;&lt;a href='http://blog.servergrove.com/2012/10/09/interesting-symfony-bundles-statsdclientbundle/'&gt;continue reading Interesting Symfony Bundles: StatsDClientBundle on ServerGrove&lt;/a&gt;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Improving the performance of a Symfony2 web application.</title>
   <link href="http://welcometothebundle.com/symfony-day-5-october-turin-2012"/>
   <updated>2012-10-31T23:01:25+01:00</updated>
   <id>http://welcometothebundle.com/symfony-day-5-october-turin-2012</id>
   <content type="html">&lt;p&gt;On October 5th, I was the speaker at the symfony day, and I was lucky enough to be able to close the conference.&lt;/p&gt;

&lt;p&gt;It was a very interesting experience, although excited I talked about what I know best: &lt;strong&gt;improving the performance of a web application&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href='http://www.slideshare.net/liuggio/rationally-boost-your-symfony2-application-with-caching-tips-and-monitoring'&gt;liuggio/rationally-boost-your-symfony2-application-with-caching-tips-and-monitoring&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[edit] Two months after the talk, visitors pass the 1,200 visits (December 2012).&lt;/p&gt;

&lt;p&gt;There were a lot of other interesting topics:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Symfony2 Security Layer&lt;/strong&gt; - by @K3A, explained in detail the most difficult part of the symfony documentation.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PHPUnit raised by Symfony2&lt;/strong&gt; of @euxpom, showed how many utensils you have for free by the Symfony2 framework&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Symfony CMF&lt;/strong&gt; of @jacoporomei described with an overwhelming sympathy a subject very dear to me the CMF and his architecture.&lt;/p&gt;

&lt;p&gt;See you next year &lt;a href='http://www.symfonyday.it'&gt;symfonyday.it&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;a special thanks @cirpo&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>2013-Software Team Manifesto</title>
   <link href="http://welcometothebundle.com/tvision-team-manifesto"/>
   <updated>2012-09-16T16:09:12+02:00</updated>
   <id>http://welcometothebundle.com/tvision-team-manifesto</id>
   <content type="html">&lt;h2 id='abstract'&gt;Abstract&lt;/h2&gt;

&lt;p&gt;In the chaos of the implicit, a programmer who joins a team must have a common language and some rules in order to have an integration without friction.&lt;/p&gt;

&lt;p&gt;There is a level 0, a common and accepted (or imposed by the architect) knowledge.&lt;/p&gt;

&lt;p&gt;This document defines the concepts and guidelines to follow in order to be a developer who can work in a software team in 2013.&lt;/p&gt;

&lt;p&gt;I think that you are already proficient with this notions.&lt;/p&gt;

&lt;p&gt;We use PHP as language and Symofony2 as framework.&lt;/p&gt;
&lt;script src='https://gist.github.com/4339207.js'&gt; &lt;/script&gt;
&lt;p&gt;Any comment or help is really appreciated,&lt;/p&gt;

&lt;p&gt;please help me to improve this document forking this &lt;a href='https://gist.github.com/4339207'&gt;gist&lt;/a&gt;.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Easily install statsd and graphite with vagrant</title>
   <link href="http://welcometothebundle.com/easily-install-statsd-and-graphite-with-vagrant"/>
   <updated>2012-07-31T00:00:00+02:00</updated>
   <id>http://welcometothebundle.com/easily-install-statsd-and-graphite-with-vagrant</id>
   <content type="html">&lt;p&gt;If Engineering at Tvision has a religion, it’s the Church of Graphs. If it moves, we track it.&lt;/p&gt;

&lt;p&gt;Ops I already heard this sentence, please read carefully this blog post &lt;a href='http://codeascraft.etsy.com/2011/02/15/measure-anything-measure-everything/'&gt;measure-anything-measure-everything&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;For your production env sure you need statsd, you do will want to use it.&lt;/p&gt;

&lt;p&gt;If your salary is paid by a website, you need to &lt;strong&gt;monitor and react&lt;/strong&gt;, you need a monitor that pushes the informations.&lt;/p&gt;

&lt;h2 id='install_statsd__graphite__carbon__whisper__linuxos__apache__python__django__mod_wsgi_'&gt;Install Statsd + Graphite + Carbon + Whisper + LinuxOS + apache + python + django + mod_wsgi &amp;#8230;&lt;/h2&gt;

&lt;p&gt;The first time I spent 3 hours installing Graphite, now with vagrant you could try Statsd+Graphite in few minutes.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Install vagrant&lt;/p&gt;

&lt;p&gt;&lt;code&gt;gem install vagrant&lt;/code&gt; (if you need see the official documentation)&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;Installing the world with &lt;a href='http://vagrantup.com/'&gt;vagrant&lt;/a&gt; is so easy&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git clone https://github.com/liuggio/vagrant-statsd-graphite-puppet.git&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cd vagrant-statsd-graphite-puppet.git&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;vagrant up&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;My repo is just a fork of &lt;code&gt;Jimdo/vagrant-statsd-graphite-puppet&lt;/code&gt; with a small bug fix&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;Say &amp;#8216;WOOOW&amp;#8217; then connect to&lt;/p&gt;

&lt;p&gt;graphite: http://localhost:8080/&lt;/p&gt;

&lt;p&gt;statsd: 8125:udp&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Everything is done, your virtual box with StatsD is ready to use, if you are a developer and you like web application YOU MUST use a web framework, if you are a php developer you SHOULD use Symfony2, if you use Symfony2 you should have a look to &lt;a href='https://github.com/liuggio/StatsDClientBundle'&gt;symfony2 liuggio StatsDClientBundle&lt;/a&gt;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Symfony2 assets on RackSpace Cloud files</title>
   <link href="http://welcometothebundle.com/symfony2-assets-on-rackspace-cloud-files"/>
   <updated>2012-05-06T00:00:00+02:00</updated>
   <id>http://welcometothebundle.com/symfony2-assets-on-rackspace-cloud-files</id>
   <content type="html">&lt;p&gt;How to use assetic on rackspace with symfony2?&lt;/p&gt;

&lt;p&gt;The problem is how to move the static files to the cloud files and get them from twig?&lt;/p&gt;

&lt;p&gt;Following some tips from the forum &lt;a href='http://groups.google.com/group/symfony2/browse_thread/thread/8e14c145683981d4'&gt;Registering (s3) stream wrapper for AsseticBundle – Symfony2 | Google Gruppi&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I created this bundle &lt;a href='https://github.com/liuggio/RackspaceCloudFilesBundle'&gt;RackspaceCloudFilesBundle&lt;/a&gt; that handles the static files easily&lt;/p&gt;

&lt;h2 id='installing'&gt;Installing&lt;/h2&gt;

&lt;h3 id='step_1'&gt;Step 1&lt;/h3&gt;

&lt;p&gt;follow the README into the &lt;a href='https://github.com/liuggio/RackspaceCloudFilesBundle
'&gt;RackspaceCloudFilesBundle&lt;/a&gt;&lt;/p&gt;

&lt;h3 id='step_2'&gt;Step 2&lt;/h3&gt;

&lt;p&gt;modify the app/config/config.yml and the app/parameters.ini&lt;/p&gt;
&lt;script src='https://gist.github.com/2420800.js'&gt; &lt;/script&gt;
&lt;h3 id='step_3'&gt;Step 3&lt;/h3&gt;

&lt;p&gt;when you will deploy a new image just run app/console assetic:dump –env=prod&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;That’s it!!!!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;PLEASE FELL FREE TO CLONE AND SEND PULL REQUEST!&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Using Github or Bitbucket as Assets container for Symfony2</title>
   <link href="http://welcometothebundle.com/using-github-or-bitbucket-as-assets-container-for-symfony2"/>
   <updated>2012-04-20T00:00:00+02:00</updated>
   <id>http://welcometothebundle.com/using-github-or-bitbucket-as-assets-container-for-symfony2</id>
   <content type="html">&lt;p&gt;I made the following changes to the config, deps and autoload in order to push all the assets directly into a github repository.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Why you should pay for CDN if you can use Github?&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id='theory'&gt;Theory&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;Php library&lt;/span&gt; the library teqneers/PHP-Stream-Wrapper-for-Git registers a stream and commit to a repository each file that is moved throw the stream&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;span&gt;Symfony2&lt;/span&gt; Assetic bundle compresses and streams the files in your local repository, and twig render the raw.github url&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;span&gt;Git-Hook&lt;/span&gt; The Post-Commit hook will push to remote repository automatically&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id='how_to'&gt;How To&lt;/h2&gt;

&lt;p&gt;Just 3 steps&lt;/p&gt;

&lt;h2 id='step_1_install_the_library_in_your_symfony2'&gt;Step 1 Install the library in your symfony2&lt;/h2&gt;

&lt;p&gt;In your deps file add the following lines, and then run bin/vendors install&lt;/p&gt;
&lt;script src='https://gist.github.com/2427058.js?file=deps'&gt; &lt;/script&gt;
&lt;p&gt;Register namespace and register stream into &lt;code&gt;app/autoload.php&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;‘/usr/bin/git’ is where your git binary are&lt;/p&gt;

&lt;p&gt;‘php-git’ is the name of the stream&lt;/p&gt;
&lt;script src='https://gist.github.com/2427058.js?file=app-autoload.php'&gt; &lt;/script&gt;
&lt;h2 id='step_2_github_or_bitbucket_repository'&gt;Step 2 Github or BitBucket Repository&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Create Repo in the root /UsingGitHubAsAssetsCloudFiles&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href='http://help.github.com/create-a-repo/'&gt;http://help.github.com/create-a-repo/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;the public url of the repo will be www.github.com/liuggio/UsingGitHubAsAssetsCloudFiles,&lt;/p&gt;

&lt;p&gt;your remote name is ‘origin’ and the branch is ‘master’&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Add the Hook into the /UsingGitHubAsAssetsCloudFiles&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;create a file into ‘/UsingGitHubAsAssetsCloudFiles/.git/hooks/post-commit’&lt;/p&gt;
&lt;script src='https://gist.github.com/2427058.js?file=UsingGitHubAsAssetsCloudFiles-.git-hooks-post-commit'&gt; &lt;/script&gt;
&lt;h2 id='step_3_configyml_and_assets'&gt;Step 3 Config.yml and Assets&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;modify your &lt;code&gt;app/config/config.yml&lt;/code&gt; in 2 different places&lt;/li&gt;
&lt;/ul&gt;
&lt;script src='https://gist.github.com/2427058.js?file=app-config-config.yml'&gt; &lt;/script&gt;
&lt;ul&gt;
&lt;li&gt;dump all the file for prod&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;app/console assetic:dump –env=prod&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;go to your symfony2 website http://yoursymfony2.com/web/app.php/hello/{YES}&lt;/p&gt;

&lt;p&gt;THAT’S ALL.&lt;/p&gt;

&lt;p&gt;Now github is hosting your assets (for free) and your web server is happy (and if your webserver is into the cloud you’ll not charged for assets )&lt;/p&gt;</content>
 </entry>
 
 
</feed>